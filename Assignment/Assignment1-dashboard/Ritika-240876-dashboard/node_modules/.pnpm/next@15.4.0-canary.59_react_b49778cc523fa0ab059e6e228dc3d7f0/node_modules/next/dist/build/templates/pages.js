"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    config: null,
    default: null,
    getServerSideProps: null,
    getStaticPaths: null,
    getStaticProps: null,
    handler: null,
    reportWebVitals: null,
    routeModule: null,
    unstable_getServerProps: null,
    unstable_getServerSideProps: null,
    unstable_getStaticParams: null,
    unstable_getStaticPaths: null,
    unstable_getStaticProps: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    config: function() {
        return config;
    },
    // Re-export the component (should be the default export).
    default: function() {
        return _default;
    },
    getServerSideProps: function() {
        return getServerSideProps;
    },
    getStaticPaths: function() {
        return getStaticPaths;
    },
    getStaticProps: function() {
        return getStaticProps;
    },
    handler: function() {
        return handler;
    },
    reportWebVitals: function() {
        return reportWebVitals;
    },
    routeModule: function() {
        return routeModule;
    },
    unstable_getServerProps: function() {
        return unstable_getServerProps;
    },
    unstable_getServerSideProps: function() {
        return unstable_getServerSideProps;
    },
    unstable_getStaticParams: function() {
        return unstable_getStaticParams;
    },
    unstable_getStaticPaths: function() {
        return unstable_getStaticPaths;
    },
    unstable_getStaticProps: function() {
        return unstable_getStaticProps;
    }
});
const _modulecompiled = require("../../server/route-modules/pages/module.compiled");
const _routekind = require("../../server/route-kind");
const _constants = require("../../server/lib/trace/constants");
const _tracer = require("../../server/lib/trace/tracer");
const _formaturl = require("../../shared/lib/router/utils/format-url");
const _routerservercontext = require("../../server/lib/router-utils/router-server-context");
const _requestmeta = require("../../server/request-meta");
const _interopdefault = require("../../server/app-render/interop-default");
const _utils = require("../../server/instrumentation/utils");
const _normalizedatapath = require("../../shared/lib/page-path/normalize-data-path");
const _helpers = require("./helpers");
const _VAR_MODULE_DOCUMENT = /*#__PURE__*/ _interop_require_wildcard(require("VAR_MODULE_DOCUMENT"));
const _VAR_MODULE_APP = /*#__PURE__*/ _interop_require_wildcard(require("VAR_MODULE_APP"));
const _VAR_USERLAND = /*#__PURE__*/ _interop_require_wildcard(require("VAR_USERLAND"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const _default = (0, _helpers.hoist)(_VAR_USERLAND, 'default');
const getStaticProps = (0, _helpers.hoist)(_VAR_USERLAND, 'getStaticProps');
const getStaticPaths = (0, _helpers.hoist)(_VAR_USERLAND, 'getStaticPaths');
const getServerSideProps = (0, _helpers.hoist)(_VAR_USERLAND, 'getServerSideProps');
const config = (0, _helpers.hoist)(_VAR_USERLAND, 'config');
const reportWebVitals = (0, _helpers.hoist)(_VAR_USERLAND, 'reportWebVitals');
const unstable_getStaticProps = (0, _helpers.hoist)(_VAR_USERLAND, 'unstable_getStaticProps');
const unstable_getStaticPaths = (0, _helpers.hoist)(_VAR_USERLAND, 'unstable_getStaticPaths');
const unstable_getStaticParams = (0, _helpers.hoist)(_VAR_USERLAND, 'unstable_getStaticParams');
const unstable_getServerProps = (0, _helpers.hoist)(_VAR_USERLAND, 'unstable_getServerProps');
const unstable_getServerSideProps = (0, _helpers.hoist)(_VAR_USERLAND, 'unstable_getServerSideProps');
const routeModule = new _modulecompiled.PagesRouteModule({
    definition: {
        kind: _routekind.RouteKind.PAGES,
        page: 'VAR_DEFINITION_PAGE',
        pathname: 'VAR_DEFINITION_PATHNAME',
        // The following aren't used in production.
        bundlePath: '',
        filename: ''
    },
    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',
    projectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',
    components: {
        // default export might not exist when optimized for data only
        App: _VAR_MODULE_APP.default,
        Document: _VAR_MODULE_DOCUMENT.default
    },
    userland: _VAR_USERLAND
});
async function handler(req, res, ctx) {
    var _routerServerGlobal_RouterServerContextSymbol, _serverFilesManifest_config_experimental, _serverFilesManifest_config;
    let srcPage = 'VAR_DEFINITION_PAGE';
    // turbopack doesn't normalize `/index` in the page name
    // so we need to to process dynamic routes properly
    // TODO: fix turbopack providing differing value from webpack
    if (process.env.TURBOPACK) {
        srcPage = srcPage.replace(/\/index$/, '') || '/';
    } else if (srcPage === '/index') {
        // we always normalize /index specifically
        srcPage = '/';
    }
    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;
    const prepareResult = await routeModule.prepare(req, res, {
        srcPage,
        multiZoneDraftMode
    });
    if (!prepareResult) {
        res.statusCode = 400;
        res.end('Bad Request');
        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());
        return null;
    }
    const { buildId, query, params, parsedUrl, originalQuery, originalPathname, buildManifest, nextFontManifest, isNextDataRequest, serverFilesManifest, reactLoadableManifest, prerenderManifest, isDraftMode, isOnDemandRevalidate, locale, locales, defaultLocale } = prepareResult;
    const routerServerContext = (_routerServerGlobal_RouterServerContextSymbol = _routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol]) == null ? void 0 : _routerServerGlobal_RouterServerContextSymbol[process.env.__NEXT_RELATIVE_PROJECT_DIR || ''];
    const onError = routeModule.instrumentationOnRequestError.bind(routeModule);
    const nextConfig = (routerServerContext == null ? void 0 : routerServerContext.nextConfig) || serverFilesManifest.config;
    const isExperimentalCompile = serverFilesManifest == null ? void 0 : (_serverFilesManifest_config = serverFilesManifest.config) == null ? void 0 : (_serverFilesManifest_config_experimental = _serverFilesManifest_config.experimental) == null ? void 0 : _serverFilesManifest_config_experimental.isExperimentalCompile;
    const isIsrFallback = Boolean((0, _requestmeta.getRequestMeta)(req, 'isIsrFallback'));
    const hasServerProps = Boolean(getServerSideProps);
    const hasStaticProps = Boolean(getStaticProps);
    const hasGetInitialProps = Boolean((_VAR_USERLAND.default || _VAR_USERLAND).getInitialProps);
    try {
        const method = req.method || 'GET';
        const tracer = (0, _tracer.getTracer)();
        const activeSpan = tracer.getActiveScopeSpan();
        const resolvedUrl = (0, _formaturl.formatUrl)({
            pathname: parsedUrl.pathname,
            // make sure to only add query values from original URL
            query: hasStaticProps ? {} : originalQuery
        });
        const publicRuntimeConfig = (routerServerContext == null ? void 0 : routerServerContext.publicRuntimeConfig) || nextConfig.publicRuntimeConfig;
        const invokeRouteModule = async (span)=>{
            var _nextConfig_i18n, _nextConfig_experimental_amp, _nextConfig_experimental_amp1;
            return routeModule.render(req, res, {
                query: hasStaticProps && !isExperimentalCompile ? {
                    ...params,
                    ...query.amp && config.amp ? {
                        amp: query.amp
                    } : {}
                } : {
                    ...query,
                    ...params
                },
                params,
                page: srcPage,
                renderContext: {
                    isDraftMode,
                    isFallback: isIsrFallback,
                    developmentNotFoundSourcePage: (0, _requestmeta.getRequestMeta)(req, 'developmentNotFoundSourcePage')
                },
                sharedContext: {
                    buildId,
                    customServer: Boolean(routerServerContext == null ? void 0 : routerServerContext.isCustomServer) || undefined,
                    deploymentId: process.env.NEXT_DEPLOYMENT_ID
                },
                renderOpts: {
                    params,
                    routeModule,
                    page: srcPage,
                    pageConfig: config || {},
                    Component: (0, _interopdefault.interopDefault)(_VAR_USERLAND),
                    ComponentMod: _VAR_USERLAND,
                    getStaticProps,
                    getStaticPaths,
                    getServerSideProps,
                    supportsDynamicResponse: !hasStaticProps,
                    buildManifest,
                    nextFontManifest,
                    reactLoadableManifest,
                    assetPrefix: nextConfig.assetPrefix,
                    strictNextHead: Boolean(nextConfig.experimental.strictNextHead),
                    previewProps: prerenderManifest.preview,
                    images: nextConfig.images,
                    nextConfigOutput: nextConfig.output,
                    optimizeCss: Boolean(nextConfig.experimental.optimizeCss),
                    nextScriptWorkers: Boolean(nextConfig.experimental.nextScriptWorkers),
                    domainLocales: (_nextConfig_i18n = nextConfig.i18n) == null ? void 0 : _nextConfig_i18n.domains,
                    crossOrigin: nextConfig.crossOrigin,
                    multiZoneDraftMode,
                    basePath: nextConfig.basePath,
                    canonicalBase: nextConfig.amp.canonicalBase || '',
                    ampOptimizerConfig: (_nextConfig_experimental_amp = nextConfig.experimental.amp) == null ? void 0 : _nextConfig_experimental_amp.optimizer,
                    disableOptimizedLoading: nextConfig.experimental.disableOptimizedLoading,
                    largePageDataBytes: nextConfig.experimental.largePageDataBytes,
                    // Only the `publicRuntimeConfig` key is exposed to the client side
                    // It'll be rendered as part of __NEXT_DATA__ on the client side
                    runtimeConfig: Object.keys(publicRuntimeConfig).length > 0 ? publicRuntimeConfig : undefined,
                    isExperimentalCompile,
                    experimental: {
                        clientTraceMetadata: nextConfig.experimental.clientTraceMetadata || []
                    },
                    locale,
                    locales,
                    defaultLocale,
                    isNextDataRequest: isNextDataRequest && (hasServerProps || hasStaticProps),
                    resolvedUrl,
                    // For getServerSideProps and getInitialProps we need to ensure we use the original URL
                    // and not the resolved URL to prevent a hydration mismatch on
                    // asPath
                    resolvedAsPath: hasServerProps || hasGetInitialProps ? (0, _formaturl.formatUrl)({
                        // we use the original URL pathname less the _next/data prefix if
                        // present
                        pathname: isNextDataRequest ? (0, _normalizedatapath.normalizeDataPath)(originalPathname) : originalPathname,
                        query: originalQuery
                    }) : resolvedUrl,
                    isOnDemandRevalidate,
                    ErrorDebug: (0, _requestmeta.getRequestMeta)(req, 'PagesErrorDebug'),
                    err: (0, _requestmeta.getRequestMeta)(req, 'invokeError'),
                    dev: routeModule.isDev,
                    // needed for experimental.optimizeCss feature
                    distDir: `${routeModule.projectDir}/${routeModule.distDir}`,
                    ampSkipValidation: (_nextConfig_experimental_amp1 = nextConfig.experimental.amp) == null ? void 0 : _nextConfig_experimental_amp1.skipValidation,
                    ampValidator: (0, _requestmeta.getRequestMeta)(req, 'ampValidator')
                }
            }).finally(()=>{
                if (!span) return;
                span.setAttributes({
                    'http.status_code': res.statusCode,
                    'next.rsc': false
                });
                const rootSpanAttributes = tracer.getRootSpanAttributes();
                // We were unable to get attributes, probably OTEL is not enabled
                if (!rootSpanAttributes) {
                    return;
                }
                if (rootSpanAttributes.get('next.span_type') !== _constants.BaseServerSpan.handleRequest) {
                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);
                    return;
                }
                const route = rootSpanAttributes.get('next.route');
                if (route) {
                    const name = `${method} ${route}`;
                    span.setAttributes({
                        'next.route': route,
                        'http.route': route,
                        'next.span_name': name
                    });
                    span.updateName(name);
                } else {
                    span.updateName(`${method} ${req.url}`);
                }
            });
        };
        // TODO: activeSpan code path is for when wrapped by
        // next-server can be removed when this is no longer used
        if (activeSpan) {
            return await invokeRouteModule(activeSpan);
        } else {
            return await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(_constants.BaseServerSpan.handleRequest, {
                    spanName: `${method} ${req.url}`,
                    kind: _tracer.SpanKind.SERVER,
                    attributes: {
                        'http.method': method,
                        'http.target': req.url
                    }
                }, invokeRouteModule));
        }
    } catch (err) {
        await onError(req, err, {
            path: req.url || '/',
            headers: req.headers,
            method: req.method || 'GET'
        }, {
            routerKind: 'Pages Router',
            routePath: srcPage,
            routeType: 'render',
            revalidateReason: (0, _utils.getRevalidateReason)({
                isRevalidate: hasStaticProps,
                isOnDemandRevalidate
            })
        });
        // rethrow so that we can handle serving error page
        throw err;
    } finally{
        // We don't allow any waitUntil work in pages API routes currently
        // so if callback is present return with resolved promise since no
        // pending work
        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());
    }
}

//# sourceMappingURL=pages.js.map