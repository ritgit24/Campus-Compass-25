"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RouteModule", {
    enumerable: true,
    get: function() {
        return RouteModule;
    }
});
const _constants = require("../../shared/lib/constants");
const _url = require("../../lib/url");
const _normalizelocalepath = require("../../shared/lib/i18n/normalize-locale-path");
const _utils = require("../../shared/lib/router/utils");
const _removepathprefix = require("../../shared/lib/router/utils/remove-path-prefix");
const _serverutils = require("../server-utils");
const _detectdomainlocale = require("../../shared/lib/i18n/detect-domain-locale");
const _gethostname = require("../../shared/lib/get-hostname");
const _apiutils = require("../api-utils");
const _normalizedatapath = require("../../shared/lib/page-path/normalize-data-path");
const _pathhasprefix = require("../../shared/lib/router/utils/path-has-prefix");
const _requestmeta = require("../request-meta");
const _normalizepagepath = require("../../shared/lib/page-path/normalize-page-path");
class RouteModule {
    constructor({ userland, definition, distDir, projectDir }){
        this.userland = userland;
        this.definition = definition;
        this.isDev = process.env.NODE_ENV === 'development';
        this.distDir = distDir;
        this.projectDir = projectDir;
    }
    async instrumentationOnRequestError(req, ...args) {
        // this is only handled here for node, for edge it
        // is handled in the adapter/loader instead
        if (process.env.NEXT_RUNTIME !== 'edge') {
            const { join } = require('node:path');
            const projectDir = (0, _requestmeta.getRequestMeta)(req, 'projectDir') || join(process.cwd(), this.projectDir);
            const { instrumentationOnRequestError } = await import('../lib/router-utils/instrumentation-globals.external');
            return instrumentationOnRequestError(projectDir, this.distDir, ...args);
        }
    }
    async loadManifests(projectDir, srcPage) {
        if (process.env.NEXT_RUNTIME !== 'edge') {
            const { loadManifestFromRelativePath } = await import('../load-manifest.external');
            const normalizedPagePath = (0, _normalizepagepath.normalizePagePath)(srcPage);
            const [routesManifest, prerenderManifest, buildManifest, reactLoadableManifest, nextFontManifest, serverFilesManifest, buildId] = await Promise.all([
                loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: _constants.ROUTES_MANIFEST
                }),
                loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: _constants.PRERENDER_MANIFEST
                }),
                loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: _constants.BUILD_MANIFEST
                }),
                loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: process.env.TURBOPACK ? `server/pages${normalizedPagePath}/${_constants.REACT_LOADABLE_MANIFEST}` : _constants.REACT_LOADABLE_MANIFEST,
                    handleMissing: true
                }),
                loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: `server/${_constants.NEXT_FONT_MANIFEST}.json`
                }),
                this.isDev ? {} : loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: _constants.SERVER_FILES_MANIFEST
                }),
                this.isDev ? 'development' : loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: _constants.BUILD_ID_FILE,
                    skipParse: true
                })
            ]);
            return {
                buildId,
                buildManifest,
                routesManifest,
                nextFontManifest,
                prerenderManifest,
                serverFilesManifest,
                reactLoadableManifest
            };
        }
        throw Object.defineProperty(new Error('Invariant: loadManifests called for edge runtime'), "__NEXT_ERROR_CODE", {
            value: "E690",
            enumerable: false,
            configurable: true
        });
    }
    async prepare(req, res, { srcPage, multiZoneDraftMode }) {
        // "prepare" is only needed for node runtime currently
        // if we want to share the normalizing logic here
        // we will need to allow passing in the i18n and similar info
        if (process.env.NEXT_RUNTIME !== 'edge') {
            const { join } = require('node:path');
            const projectDir = (0, _requestmeta.getRequestMeta)(req, 'projectDir') || join(process.cwd(), this.projectDir);
            const { ensureInstrumentationRegistered } = await import('../lib/router-utils/instrumentation-globals.external');
            // ensure instrumentation is registered and pass
            // onRequestError below
            ensureInstrumentationRegistered(projectDir, this.distDir);
            const manifests = await this.loadManifests(projectDir, srcPage);
            const { routesManifest, prerenderManifest } = manifests;
            const { basePath, i18n, rewrites } = routesManifest;
            if (basePath) {
                req.url = (0, _removepathprefix.removePathPrefix)(req.url || '/', basePath);
            }
            const parsedUrl = (0, _url.parseReqUrl)(req.url || '/');
            // if we couldn't parse the URL we can't continue
            if (!parsedUrl) {
                return;
            }
            let isNextDataRequest = false;
            if ((0, _pathhasprefix.pathHasPrefix)(parsedUrl.pathname || '/', '/_next/data')) {
                isNextDataRequest = true;
                parsedUrl.pathname = (0, _normalizedatapath.normalizeDataPath)(parsedUrl.pathname || '/');
            }
            let originalPathname = parsedUrl.pathname || '/';
            const originalQuery = {
                ...parsedUrl.query
            };
            const pageIsDynamic = (0, _utils.isDynamicRoute)(srcPage);
            let localeResult;
            let detectedLocale;
            if (i18n) {
                localeResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedUrl.pathname || '/', i18n.locales);
                if (localeResult.detectedLocale) {
                    req.url = `${localeResult.pathname}${parsedUrl.search}`;
                    originalPathname = localeResult.pathname;
                    if (!detectedLocale) {
                        detectedLocale = localeResult.detectedLocale;
                    }
                }
            }
            const serverUtils = (0, _serverutils.getServerUtils)({
                page: srcPage,
                i18n,
                basePath,
                rewrites,
                pageIsDynamic,
                trailingSlash: process.env.__NEXT_TRAILING_SLASH,
                caseSensitive: Boolean(routesManifest.caseSensitive)
            });
            const domainLocale = (0, _detectdomainlocale.detectDomainLocale)(i18n == null ? void 0 : i18n.domains, (0, _gethostname.getHostname)(parsedUrl, req.headers), detectedLocale);
            (0, _requestmeta.addRequestMeta)(req, 'isLocaleDomain', Boolean(domainLocale));
            const defaultLocale = (domainLocale == null ? void 0 : domainLocale.defaultLocale) || (i18n == null ? void 0 : i18n.defaultLocale);
            // Ensure parsedUrl.pathname includes locale before processing
            // rewrites or they won't match correctly.
            if (defaultLocale && !detectedLocale) {
                parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname}`;
            }
            const locale = (0, _requestmeta.getRequestMeta)(req, 'locale') || detectedLocale || defaultLocale;
            const rewriteParamKeys = Object.keys(serverUtils.handleRewrites(req, parsedUrl));
            // after processing rewrites we want to remove locale
            // from parsedUrl pathname
            if (i18n) {
                parsedUrl.pathname = (0, _normalizelocalepath.normalizeLocalePath)(parsedUrl.pathname || '/', i18n.locales).pathname;
            }
            let params = (0, _requestmeta.getRequestMeta)(req, 'params');
            // attempt parsing from pathname
            if (!params && serverUtils.dynamicRouteMatcher) {
                const paramsResult = serverUtils.dynamicRouteMatcher((0, _normalizedatapath.normalizeDataPath)((localeResult == null ? void 0 : localeResult.pathname) || parsedUrl.pathname || '/'));
                if (paramsResult) {
                    params = paramsResult;
                }
            }
            // Local "next start" expects the routing parsed query values
            // to not be present in the URL although when deployed proxies
            // will add query values from resolving the routes to pass to function.
            // TODO: do we want to change expectations for "next start"
            // to include these query values in the URL which affects asPath
            // but would match deployed behavior, e.g. a rewrite from middleware
            // that adds a query param would be in asPath as query but locally
            // it won't be in the asPath but still available in the query object
            const query = (0, _requestmeta.getRequestMeta)(req, 'query') || {
                ...parsedUrl.query
            };
            const routeParamKeys = new Set();
            const combinedParamKeys = [
                ...rewriteParamKeys,
                ...routeParamKeys
            ];
            serverUtils.normalizeCdnUrl(req, combinedParamKeys);
            serverUtils.normalizeQueryParams(query, routeParamKeys);
            serverUtils.filterInternalQuery(originalQuery, combinedParamKeys);
            if (pageIsDynamic) {
                const result = serverUtils.normalizeDynamicRouteParams(query, true);
                req.url = serverUtils.interpolateDynamicPath(req.url || '/', params || query);
                parsedUrl.pathname = serverUtils.interpolateDynamicPath(parsedUrl.pathname || '/', params || query);
                originalPathname = serverUtils.interpolateDynamicPath(originalPathname, params || query);
                // try pulling from query if valid
                if (result.hasValidParams) {
                    params = Object.assign({}, result.params, params);
                    // If we pulled from query remove it so it's
                    // only in params
                    for(const key in params){
                        delete query[key];
                    }
                }
            }
            // Remove any normalized params from the query if they
            // weren't present as non-prefixed query key e.g.
            // ?search=1&nxtPsearch=hello we don't delete search
            for (const key of routeParamKeys){
                if (!(key in originalQuery)) {
                    delete query[key];
                }
            }
            const { isOnDemandRevalidate, revalidateOnlyGenerated } = (0, _apiutils.checkIsOnDemandRevalidate)(req, prerenderManifest.preview);
            let isDraftMode = false;
            let previewData;
            const { tryGetPreviewData } = require('../api-utils/node/try-get-preview-data');
            previewData = tryGetPreviewData(req, res, prerenderManifest.preview, Boolean(multiZoneDraftMode));
            isDraftMode = previewData !== false;
            return {
                query,
                originalQuery,
                originalPathname,
                params,
                parsedUrl,
                locale,
                isNextDataRequest,
                locales: i18n == null ? void 0 : i18n.locales,
                defaultLocale,
                isDraftMode,
                previewData,
                isOnDemandRevalidate,
                revalidateOnlyGenerated,
                ...manifests
            };
        }
    }
}

//# sourceMappingURL=route-module.js.map