"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    Draggable: null,
    useDrag: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    Draggable: function() {
        return Draggable;
    },
    useDrag: function() {
        return useDrag;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = require("react");
function Draggable(param) {
    let { children, padding, position: currentCorner, setPosition: setCurrentCorner, onDragStart } = param;
    const { ref, animate, ...drag } = useDrag({
        threshold: 5,
        onDragStart,
        onDragEnd,
        onAnimationEnd
    });
    function onDragEnd(translation, velocity) {
        const projectedPosition = {
            x: translation.x + project(velocity.x),
            y: translation.y + project(velocity.y)
        };
        const nearestCorner = getNearestCorner(projectedPosition);
        animate(nearestCorner);
    }
    function onAnimationEnd(param) {
        let { corner } = param;
        // Unset drag translation
        setTimeout(()=>{
            var _ref_current;
            (_ref_current = ref.current) == null ? void 0 : _ref_current.style.removeProperty('translate');
            setCurrentCorner(corner);
        });
    }
    function getNearestCorner(param) {
        let { x, y } = param;
        const allCorners = getCorners();
        const distances = Object.entries(allCorners).map((param)=>{
            let [key, translation] = param;
            const distance = Math.sqrt((x - translation.x) ** 2 + (y - translation.y) ** 2);
            return {
                key,
                distance
            };
        });
        const min = Math.min(...distances.map((d)=>d.distance));
        const nearest = distances.find((d)=>d.distance === min);
        if (!nearest) {
            // Safety fallback
            return {
                corner: currentCorner,
                translation: allCorners[currentCorner]
            };
        }
        return {
            translation: allCorners[nearest.key],
            corner: nearest.key
        };
    }
    function getCorners() {
        var _ref_current, _ref_current1;
        const offset = padding * 2;
        const triggerWidth = ((_ref_current = ref.current) == null ? void 0 : _ref_current.offsetWidth) || 0;
        const triggerHeight = ((_ref_current1 = ref.current) == null ? void 0 : _ref_current1.offsetHeight) || 0;
        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
        function getAbsolutePosition(corner) {
            const isRight = corner.includes('right');
            const isBottom = corner.includes('bottom');
            return {
                x: isRight ? window.innerWidth - scrollbarWidth - offset - triggerWidth : 0,
                y: isBottom ? window.innerHeight - offset - triggerHeight : 0
            };
        }
        const basePosition = getAbsolutePosition(currentCorner);
        // Calculate all corner positions relative to the current corner
        return {
            'top-left': {
                x: 0 - basePosition.x,
                y: 0 - basePosition.y
            },
            'top-right': {
                x: window.innerWidth - scrollbarWidth - offset - triggerWidth - basePosition.x,
                y: 0 - basePosition.y
            },
            'bottom-left': {
                x: 0 - basePosition.x,
                y: window.innerHeight - offset - triggerHeight - basePosition.y
            },
            'bottom-right': {
                x: window.innerWidth - scrollbarWidth - offset - triggerWidth - basePosition.x,
                y: window.innerHeight - offset - triggerHeight - basePosition.y
            }
        };
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
        ref: ref,
        ...drag,
        style: {
            touchAction: 'none'
        },
        children: children
    });
}
function useDrag(options) {
    const ref = (0, _react.useRef)(null);
    const state = (0, _react.useRef)('idle');
    const origin = (0, _react.useRef)({
        x: 0,
        y: 0
    });
    const translation = (0, _react.useRef)({
        x: 0,
        y: 0
    });
    const lastTimestamp = (0, _react.useRef)(0);
    const velocities = (0, _react.useRef)([]);
    function set(position) {
        if (ref.current) {
            translation.current = position;
            ref.current.style.translate = position.x + "px " + position.y + "px";
        }
    }
    function animate(corner) {
        const el = ref.current;
        if (el === null) return;
        function listener(e) {
            if (e.propertyName === 'translate') {
                options.onAnimationEnd == null ? void 0 : options.onAnimationEnd.call(options, corner);
                translation.current = {
                    x: 0,
                    y: 0
                };
                el.style.transition = '';
                el.removeEventListener('transitionend', listener);
            }
        }
        // Generated from https://www.easing.dev/spring
        el.style.transition = 'translate 491.22ms var(--timing-bounce)';
        el.addEventListener('transitionend', listener);
        set(corner.translation);
    }
    function onClick(e) {
        if (state.current === 'drag-end') {
            var _ref_current;
            e.preventDefault();
            e.stopPropagation();
            state.current = 'idle';
            (_ref_current = ref.current) == null ? void 0 : _ref_current.removeEventListener('click', onClick);
        }
    }
    function onPointerDown(e) {
        var _ref_current;
        if (e.button !== 0) {
            return; // ignore right click
        }
        origin.current = {
            x: e.clientX,
            y: e.clientY
        };
        state.current = 'press';
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
        (_ref_current = ref.current) == null ? void 0 : _ref_current.addEventListener('click', onClick);
    }
    function onPointerMove(e) {
        if (state.current === 'press') {
            const dx = e.clientX - origin.current.x;
            const dy = e.clientY - origin.current.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance >= options.threshold) {
                var _ref_current, _ref_current1;
                state.current = 'drag';
                (_ref_current = ref.current) == null ? void 0 : _ref_current.setPointerCapture(e.pointerId);
                (_ref_current1 = ref.current) == null ? void 0 : _ref_current1.classList.add('dev-tools-grabbing');
                options.onDragStart == null ? void 0 : options.onDragStart.call(options);
            }
        }
        if (state.current !== 'drag') return;
        const currentPosition = {
            x: e.clientX,
            y: e.clientY
        };
        const dx = currentPosition.x - origin.current.x;
        const dy = currentPosition.y - origin.current.y;
        origin.current = currentPosition;
        const newTranslation = {
            x: translation.current.x + dx,
            y: translation.current.y + dy
        };
        set(newTranslation);
        // Keep a history of recent positions for velocity calculation
        // Only store points that are at least 10ms apart to avoid too many samples
        const now = Date.now();
        const shouldAddToHistory = now - lastTimestamp.current >= 10;
        if (shouldAddToHistory) {
            velocities.current = [
                ...velocities.current.slice(-5),
                {
                    position: currentPosition,
                    timestamp: now
                }
            ];
        }
        lastTimestamp.current = now;
        options.onDrag == null ? void 0 : options.onDrag.call(options, translation.current);
    }
    function onPointerUp(e) {
        var _ref_current, _ref_current1;
        state.current = state.current === 'drag' ? 'drag-end' : 'idle';
        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', onPointerUp);
        const velocity = calculateVelocity(velocities.current);
        velocities.current = [];
        (_ref_current = ref.current) == null ? void 0 : _ref_current.classList.remove('dev-tools-grabbing');
        (_ref_current1 = ref.current) == null ? void 0 : _ref_current1.releasePointerCapture(e.pointerId);
        options.onDragEnd == null ? void 0 : options.onDragEnd.call(options, translation.current, velocity);
    }
    return {
        ref,
        onPointerDown,
        animate
    };
}
function calculateVelocity(history) {
    if (history.length < 2) {
        return {
            x: 0,
            y: 0
        };
    }
    const oldestPoint = history[0];
    const latestPoint = history[history.length - 1];
    const timeDelta = latestPoint.timestamp - oldestPoint.timestamp;
    if (timeDelta === 0) {
        return {
            x: 0,
            y: 0
        };
    }
    // Calculate pixels per millisecond
    const velocityX = (latestPoint.position.x - oldestPoint.position.x) / timeDelta;
    const velocityY = (latestPoint.position.y - oldestPoint.position.y) / timeDelta;
    // Convert to pixels per second for more intuitive values
    return {
        x: velocityX * 1000,
        y: velocityY * 1000
    };
}
function project(initialVelocity, decelerationRate) {
    if (decelerationRate === void 0) decelerationRate = 0.999;
    return initialVelocity / 1000 * decelerationRate / (1 - decelerationRate);
}

if ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {
  Object.defineProperty(exports.default, '__esModule', { value: true });
  Object.assign(exports.default, exports);
  module.exports = exports.default;
}

//# sourceMappingURL=draggable.js.map