import { BUILD_ID_FILE, BUILD_MANIFEST, NEXT_FONT_MANIFEST, PRERENDER_MANIFEST, REACT_LOADABLE_MANIFEST, ROUTES_MANIFEST, SERVER_FILES_MANIFEST } from '../../shared/lib/constants';
import { parseReqUrl } from '../../lib/url';
import { normalizeLocalePath } from '../../shared/lib/i18n/normalize-locale-path';
import { isDynamicRoute } from '../../shared/lib/router/utils';
import { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix';
import { getServerUtils } from '../server-utils';
import { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale';
import { getHostname } from '../../shared/lib/get-hostname';
import { checkIsOnDemandRevalidate } from '../api-utils';
import { normalizeDataPath } from '../../shared/lib/page-path/normalize-data-path';
import { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix';
import { addRequestMeta, getRequestMeta } from '../request-meta';
import { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path';
/**
 * RouteModule is the base class for all route modules. This class should be
 * extended by all route modules.
 */ export class RouteModule {
    constructor({ userland, definition, distDir, projectDir }){
        this.userland = userland;
        this.definition = definition;
        this.isDev = process.env.NODE_ENV === 'development';
        this.distDir = distDir;
        this.projectDir = projectDir;
    }
    async instrumentationOnRequestError(req, ...args) {
        // this is only handled here for node, for edge it
        // is handled in the adapter/loader instead
        if (process.env.NEXT_RUNTIME !== 'edge') {
            const { join } = require('node:path');
            const projectDir = getRequestMeta(req, 'projectDir') || join(process.cwd(), this.projectDir);
            const { instrumentationOnRequestError } = await import('../lib/router-utils/instrumentation-globals.external');
            return instrumentationOnRequestError(projectDir, this.distDir, ...args);
        }
    }
    async loadManifests(projectDir, srcPage) {
        if (process.env.NEXT_RUNTIME !== 'edge') {
            const { loadManifestFromRelativePath } = await import('../load-manifest.external');
            const normalizedPagePath = normalizePagePath(srcPage);
            const [routesManifest, prerenderManifest, buildManifest, reactLoadableManifest, nextFontManifest, serverFilesManifest, buildId] = await Promise.all([
                loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: ROUTES_MANIFEST
                }),
                loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: PRERENDER_MANIFEST
                }),
                loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: BUILD_MANIFEST
                }),
                loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: process.env.TURBOPACK ? `server/pages${normalizedPagePath}/${REACT_LOADABLE_MANIFEST}` : REACT_LOADABLE_MANIFEST,
                    handleMissing: true
                }),
                loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: `server/${NEXT_FONT_MANIFEST}.json`
                }),
                this.isDev ? {} : loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: SERVER_FILES_MANIFEST
                }),
                this.isDev ? 'development' : loadManifestFromRelativePath({
                    projectDir,
                    distDir: this.distDir,
                    manifest: BUILD_ID_FILE,
                    skipParse: true
                })
            ]);
            return {
                buildId,
                buildManifest,
                routesManifest,
                nextFontManifest,
                prerenderManifest,
                serverFilesManifest,
                reactLoadableManifest
            };
        }
        throw Object.defineProperty(new Error('Invariant: loadManifests called for edge runtime'), "__NEXT_ERROR_CODE", {
            value: "E690",
            enumerable: false,
            configurable: true
        });
    }
    async prepare(req, res, { srcPage, multiZoneDraftMode }) {
        // "prepare" is only needed for node runtime currently
        // if we want to share the normalizing logic here
        // we will need to allow passing in the i18n and similar info
        if (process.env.NEXT_RUNTIME !== 'edge') {
            const { join } = require('node:path');
            const projectDir = getRequestMeta(req, 'projectDir') || join(process.cwd(), this.projectDir);
            const { ensureInstrumentationRegistered } = await import('../lib/router-utils/instrumentation-globals.external');
            // ensure instrumentation is registered and pass
            // onRequestError below
            ensureInstrumentationRegistered(projectDir, this.distDir);
            const manifests = await this.loadManifests(projectDir, srcPage);
            const { routesManifest, prerenderManifest } = manifests;
            const { basePath, i18n, rewrites } = routesManifest;
            if (basePath) {
                req.url = removePathPrefix(req.url || '/', basePath);
            }
            const parsedUrl = parseReqUrl(req.url || '/');
            // if we couldn't parse the URL we can't continue
            if (!parsedUrl) {
                return;
            }
            let isNextDataRequest = false;
            if (pathHasPrefix(parsedUrl.pathname || '/', '/_next/data')) {
                isNextDataRequest = true;
                parsedUrl.pathname = normalizeDataPath(parsedUrl.pathname || '/');
            }
            let originalPathname = parsedUrl.pathname || '/';
            const originalQuery = {
                ...parsedUrl.query
            };
            const pageIsDynamic = isDynamicRoute(srcPage);
            let localeResult;
            let detectedLocale;
            if (i18n) {
                localeResult = normalizeLocalePath(parsedUrl.pathname || '/', i18n.locales);
                if (localeResult.detectedLocale) {
                    req.url = `${localeResult.pathname}${parsedUrl.search}`;
                    originalPathname = localeResult.pathname;
                    if (!detectedLocale) {
                        detectedLocale = localeResult.detectedLocale;
                    }
                }
            }
            const serverUtils = getServerUtils({
                page: srcPage,
                i18n,
                basePath,
                rewrites,
                pageIsDynamic,
                trailingSlash: process.env.__NEXT_TRAILING_SLASH,
                caseSensitive: Boolean(routesManifest.caseSensitive)
            });
            const domainLocale = detectDomainLocale(i18n == null ? void 0 : i18n.domains, getHostname(parsedUrl, req.headers), detectedLocale);
            addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale));
            const defaultLocale = (domainLocale == null ? void 0 : domainLocale.defaultLocale) || (i18n == null ? void 0 : i18n.defaultLocale);
            // Ensure parsedUrl.pathname includes locale before processing
            // rewrites or they won't match correctly.
            if (defaultLocale && !detectedLocale) {
                parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname}`;
            }
            const locale = getRequestMeta(req, 'locale') || detectedLocale || defaultLocale;
            const rewriteParamKeys = Object.keys(serverUtils.handleRewrites(req, parsedUrl));
            // after processing rewrites we want to remove locale
            // from parsedUrl pathname
            if (i18n) {
                parsedUrl.pathname = normalizeLocalePath(parsedUrl.pathname || '/', i18n.locales).pathname;
            }
            let params = getRequestMeta(req, 'params');
            // attempt parsing from pathname
            if (!params && serverUtils.dynamicRouteMatcher) {
                const paramsResult = serverUtils.dynamicRouteMatcher(normalizeDataPath((localeResult == null ? void 0 : localeResult.pathname) || parsedUrl.pathname || '/'));
                if (paramsResult) {
                    params = paramsResult;
                }
            }
            // Local "next start" expects the routing parsed query values
            // to not be present in the URL although when deployed proxies
            // will add query values from resolving the routes to pass to function.
            // TODO: do we want to change expectations for "next start"
            // to include these query values in the URL which affects asPath
            // but would match deployed behavior, e.g. a rewrite from middleware
            // that adds a query param would be in asPath as query but locally
            // it won't be in the asPath but still available in the query object
            const query = getRequestMeta(req, 'query') || {
                ...parsedUrl.query
            };
            const routeParamKeys = new Set();
            const combinedParamKeys = [
                ...rewriteParamKeys,
                ...routeParamKeys
            ];
            serverUtils.normalizeCdnUrl(req, combinedParamKeys);
            serverUtils.normalizeQueryParams(query, routeParamKeys);
            serverUtils.filterInternalQuery(originalQuery, combinedParamKeys);
            if (pageIsDynamic) {
                const result = serverUtils.normalizeDynamicRouteParams(query, true);
                req.url = serverUtils.interpolateDynamicPath(req.url || '/', params || query);
                parsedUrl.pathname = serverUtils.interpolateDynamicPath(parsedUrl.pathname || '/', params || query);
                originalPathname = serverUtils.interpolateDynamicPath(originalPathname, params || query);
                // try pulling from query if valid
                if (result.hasValidParams) {
                    params = Object.assign({}, result.params, params);
                    // If we pulled from query remove it so it's
                    // only in params
                    for(const key in params){
                        delete query[key];
                    }
                }
            }
            // Remove any normalized params from the query if they
            // weren't present as non-prefixed query key e.g.
            // ?search=1&nxtPsearch=hello we don't delete search
            for (const key of routeParamKeys){
                if (!(key in originalQuery)) {
                    delete query[key];
                }
            }
            const { isOnDemandRevalidate, revalidateOnlyGenerated } = checkIsOnDemandRevalidate(req, prerenderManifest.preview);
            let isDraftMode = false;
            let previewData;
            const { tryGetPreviewData } = require('../api-utils/node/try-get-preview-data');
            previewData = tryGetPreviewData(req, res, prerenderManifest.preview, Boolean(multiZoneDraftMode));
            isDraftMode = previewData !== false;
            return {
                query,
                originalQuery,
                originalPathname,
                params,
                parsedUrl,
                locale,
                isNextDataRequest,
                locales: i18n == null ? void 0 : i18n.locales,
                defaultLocale,
                isDraftMode,
                previewData,
                isOnDemandRevalidate,
                revalidateOnlyGenerated,
                ...manifests
            };
        }
    }
}

//# sourceMappingURL=route-module.js.map