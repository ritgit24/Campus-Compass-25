{"version":3,"sources":["../../src/server/base-server.ts"],"sourcesContent":["import type { __ApiPreviewProps } from './api-utils'\nimport type { LoadComponentsReturnType } from './load-components'\nimport type { MiddlewareRouteMatch } from '../shared/lib/router/utils/middleware-route-matcher'\nimport type { Params } from './request/params'\nimport {\n  type FallbackRouteParams,\n  getFallbackRouteParams,\n} from './request/fallback-params'\nimport type { NextConfig, NextConfigComplete } from './config-shared'\nimport type {\n  NextParsedUrlQuery,\n  NextUrlWithParsedQuery,\n  RequestMeta,\n} from './request-meta'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { RenderOptsPartial as PagesRenderOptsPartial } from './render'\nimport type {\n  RenderOptsPartial as AppRenderOptsPartial,\n  ServerOnInstrumentationRequestError,\n} from './app-render/types'\nimport {\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type ServerComponentsHmrCache,\n  type ResponseCacheBase,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n  CachedRouteKind,\n  type CachedRedirectValue,\n} from './response-cache'\nimport type { UrlWithParsedQuery } from 'url'\nimport {\n  NormalizeError,\n  DecodeError,\n  normalizeRepeatedSlashes,\n  MissingStaticPage,\n} from '../shared/lib/utils'\nimport type { PreviewData } from '../types'\nimport type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'\nimport type { BaseNextRequest, BaseNextResponse } from './base-http'\nimport type {\n  ManifestRewriteRoute,\n  ManifestRoute,\n  PrerenderManifest,\n} from '../build'\nimport type { ClientReferenceManifest } from '../build/webpack/plugins/flight-manifest-plugin'\nimport type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin'\nimport type {\n  AppPageRouteHandlerContext,\n  AppPageRouteModule,\n} from './route-modules/app-page/module'\nimport type { PagesAPIRouteMatch } from './route-matches/pages-api-route-match'\nimport type { AppRouteRouteHandlerContext } from './route-modules/app-route/module'\nimport type {\n  Server as HTTPServer,\n  IncomingMessage,\n  ServerResponse as HTTPServerResponse,\n} from 'http'\nimport type { MiddlewareMatcher } from '../build/analysis/get-page-static-info'\nimport type { TLSSocket } from 'tls'\nimport type { PathnameNormalizer } from './normalizers/request/pathname-normalizer'\nimport type { InstrumentationModule } from './instrumentation/types'\n\nimport { format as formatUrl, parse as parseUrl } from 'url'\nimport { formatHostname } from './lib/format-hostname'\nimport { getRedirectStatus } from '../lib/redirect-status'\nimport { isEdgeRuntime } from '../lib/is-edge-runtime'\nimport {\n  APP_PATHS_MANIFEST,\n  NEXT_BUILTIN_DOCUMENT,\n  PAGES_MANIFEST,\n  STATIC_STATUS_PAGES,\n  UNDERSCORE_NOT_FOUND_ROUTE,\n  UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n} from '../shared/lib/constants'\nimport { isDynamicRoute } from '../shared/lib/router/utils'\nimport { checkIsOnDemandRevalidate } from './api-utils'\nimport { setConfig } from '../shared/lib/runtime-config.external'\nimport { getCacheControlHeader, type CacheControl } from './lib/cache-control'\nimport { execOnce } from '../shared/lib/utils'\nimport { isBlockedPage } from './utils'\nimport { getBotType, isBot } from '../shared/lib/router/utils/is-bot'\nimport RenderResult from './render-result'\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'\nimport * as Log from '../build/output/log'\nimport { getPreviouslyRevalidatedTags, getServerUtils } from './server-utils'\nimport isError, { getProperError } from '../lib/is-error'\nimport {\n  addRequestMeta,\n  getRequestMeta,\n  removeRequestMeta,\n  setRequestMeta,\n} from './request-meta'\nimport { removePathPrefix } from '../shared/lib/router/utils/remove-path-prefix'\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths'\nimport { getHostname } from '../shared/lib/get-hostname'\nimport { parseUrl as parseUrlUtil } from '../shared/lib/router/utils/parse-url'\nimport { getNextPathnameInfo } from '../shared/lib/router/utils/get-next-pathname-info'\nimport {\n  RSC_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_URL,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n} from '../client/components/app-router-headers'\nimport type {\n  MatchOptions,\n  RouteMatcherManager,\n} from './route-matcher-managers/route-matcher-manager'\nimport { LocaleRouteNormalizer } from './normalizers/locale-route-normalizer'\nimport { DefaultRouteMatcherManager } from './route-matcher-managers/default-route-matcher-manager'\nimport { AppPageRouteMatcherProvider } from './route-matcher-providers/app-page-route-matcher-provider'\nimport { AppRouteRouteMatcherProvider } from './route-matcher-providers/app-route-route-matcher-provider'\nimport { PagesAPIRouteMatcherProvider } from './route-matcher-providers/pages-api-route-matcher-provider'\nimport { PagesRouteMatcherProvider } from './route-matcher-providers/pages-route-matcher-provider'\nimport { ServerManifestLoader } from './route-matcher-providers/helpers/manifest-loaders/server-manifest-loader'\nimport { getTracer, isBubbledError, SpanKind } from './lib/trace/tracer'\nimport { BaseServerSpan } from './lib/trace/constants'\nimport { I18NProvider } from './lib/i18n-provider'\nimport { sendResponse } from './send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  normalizeNextQueryParam,\n  toNodeOutgoingHttpHeaders,\n} from './web/utils'\nimport {\n  CACHE_ONE_YEAR,\n  INFINITE_CACHE,\n  MATCHED_PATH_HEADER,\n  NEXT_CACHE_TAGS_HEADER,\n  NEXT_RESUME_HEADER,\n} from '../lib/constants'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from './web/spec-extension/adapters/next-request'\nimport { matchNextDataPathname } from './lib/match-next-data-pathname'\nimport getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path'\nimport { decodePathParams } from './lib/router-utils/decode-path-params'\nimport { RSCPathnameNormalizer } from './normalizers/request/rsc'\nimport { stripFlightHeaders } from './app-render/strip-flight-headers'\nimport {\n  isAppPageRouteModule,\n  isAppRouteRouteModule,\n  isPagesRouteModule,\n} from './route-modules/checks'\nimport { PrefetchRSCPathnameNormalizer } from './normalizers/request/prefetch-rsc'\nimport { NextDataPathnameNormalizer } from './normalizers/request/next-data'\nimport { getIsPossibleServerAction } from './lib/server-action-request-meta'\nimport { isInterceptionRouteAppPath } from '../shared/lib/router/utils/interception-routes'\nimport { toRoute } from './lib/to-route'\nimport type { DeepReadonly } from '../shared/lib/deep-readonly'\nimport { isNodeNextRequest, isNodeNextResponse } from './base-http/helpers'\nimport { patchSetHeaderWithCookieSupport } from './lib/patch-set-header'\nimport { checkIsAppPPREnabled } from './lib/experimental/ppr'\nimport {\n  getBuiltinRequestContext,\n  type WaitUntil,\n} from './after/builtin-request-context'\nimport { ENCODED_TAGS } from './stream-utils/encodedTags'\nimport { NextRequestHint } from './web/adapter'\nimport { getRevalidateReason } from './instrumentation/utils'\nimport { RouteKind } from './route-kind'\nimport type { RouteModule } from './route-modules/route-module'\nimport { FallbackMode, parseFallbackField } from '../lib/fallback'\nimport { toResponseCacheEntry } from './response-cache/utils'\nimport { SegmentPrefixRSCPathnameNormalizer } from './normalizers/request/segment-prefix-rsc'\nimport {\n  shouldServeStreamingMetadata,\n  isHtmlBotRequest,\n} from './lib/streaming-metadata'\nimport { InvariantError } from '../shared/lib/invariant-error'\nimport { decodeQueryPathParameter } from './lib/decode-query-path-parameter'\nimport { getCacheHandlers } from './use-cache/handlers'\nimport { fixMojibake } from './lib/fix-mojibake'\nimport { computeCacheBustingSearchParam } from '../shared/lib/router/utils/cache-busting-search-param'\n\nexport type FindComponentsResult = {\n  components: LoadComponentsReturnType\n  query: NextParsedUrlQuery\n}\n\nexport interface MiddlewareRoutingItem {\n  page: string\n  match: MiddlewareRouteMatch\n  matchers?: MiddlewareMatcher[]\n}\n\nexport type RouteHandler<\n  ServerRequest extends BaseNextRequest = BaseNextRequest,\n  ServerResponse extends BaseNextResponse = BaseNextResponse,\n> = (\n  req: ServerRequest,\n  res: ServerResponse,\n  parsedUrl: NextUrlWithParsedQuery\n) => PromiseLike<boolean> | boolean\n\n/**\n * The normalized route manifest is the same as the route manifest, but with\n * the rewrites normalized to the object shape that the router expects.\n */\nexport type NormalizedRouteManifest = {\n  readonly dynamicRoutes: ReadonlyArray<ManifestRoute>\n  readonly rewrites: {\n    readonly beforeFiles: ReadonlyArray<ManifestRewriteRoute>\n    readonly afterFiles: ReadonlyArray<ManifestRewriteRoute>\n    readonly fallback: ReadonlyArray<ManifestRewriteRoute>\n  }\n}\n\nexport interface Options {\n  /**\n   * Object containing the configuration next.config.js\n   */\n  conf: NextConfig\n  /**\n   * Set to false when the server was created by Next.js\n   */\n  customServer?: boolean\n  /**\n   * Tells if Next.js is running in dev mode\n   */\n  dev?: boolean\n  /**\n   * Enables the experimental testing mode.\n   */\n  experimentalTestProxy?: boolean\n\n  /**\n   * Whether or not the dev server is running in experimental HTTPS mode\n   */\n  experimentalHttpsServer?: boolean\n  /**\n   * Where the Next project is located\n   */\n  dir?: string\n  /**\n   * Tells if Next.js is at the platform-level\n   */\n  minimalMode?: boolean\n  /**\n   * Hide error messages containing server information\n   */\n  quiet?: boolean\n  /**\n   * The hostname the server is running behind\n   */\n  hostname?: string\n  /**\n   * The port the server is running behind\n   */\n  port?: number\n  /**\n   * The HTTP Server that Next.js is running behind\n   */\n  httpServer?: HTTPServer\n}\n\nexport type RenderOpts = PagesRenderOptsPartial & AppRenderOptsPartial\n\nexport type LoadedRenderOpts = RenderOpts &\n  LoadComponentsReturnType &\n  RequestLifecycleOpts\n\nexport type RequestLifecycleOpts = {\n  waitUntil: ((promise: Promise<any>) => void) | undefined\n  onClose: (callback: () => void) => void\n  onAfterTaskError: ((error: unknown) => void) | undefined\n}\n\ntype BaseRenderOpts = RenderOpts & {\n  poweredByHeader: boolean\n  generateEtags: boolean\n  previewProps: __ApiPreviewProps\n}\n\n/**\n * The public interface for rendering with the server programmatically. This\n * would typically only allow the base request or response to extend it, but\n * because this can be programmatically accessed, we assume that it could also\n * be the base Node.js request and response types.\n */\nexport interface BaseRequestHandler<\n  ServerRequest extends BaseNextRequest | IncomingMessage = BaseNextRequest,\n  ServerResponse extends\n    | BaseNextResponse\n    | HTTPServerResponse = BaseNextResponse,\n> {\n  (\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery | undefined\n  ): Promise<void> | void\n}\n\nexport type RequestContext<\n  ServerRequest extends BaseNextRequest = BaseNextRequest,\n  ServerResponse extends BaseNextResponse = BaseNextResponse,\n> = {\n  req: ServerRequest\n  res: ServerResponse\n  pathname: string\n  query: NextParsedUrlQuery\n  renderOpts: RenderOpts\n}\n\nexport class NoFallbackError extends Error {}\n\n// Internal wrapper around build errors at development\n// time, to prevent us from propagating or logging them\nexport class WrappedBuildError extends Error {\n  innerError: Error\n\n  constructor(innerError: Error) {\n    super()\n    this.innerError = innerError\n  }\n}\n\ntype ResponsePayload = {\n  type: 'html' | 'json' | 'rsc'\n  body: RenderResult\n  cacheControl?: CacheControl\n}\n\nexport type NextEnabledDirectories = {\n  readonly pages: boolean\n  readonly app: boolean\n}\n\nexport default abstract class Server<\n  ServerOptions extends Options = Options,\n  ServerRequest extends BaseNextRequest = BaseNextRequest,\n  ServerResponse extends BaseNextResponse = BaseNextResponse,\n> {\n  public readonly hostname?: string\n  public readonly fetchHostname?: string\n  public readonly port?: number\n  protected readonly dir: string\n  protected readonly quiet: boolean\n  protected readonly nextConfig: NextConfigComplete\n  protected readonly distDir: string\n  protected readonly publicDir: string\n  protected readonly hasStaticDir: boolean\n  protected readonly pagesManifest?: PagesManifest\n  protected readonly appPathsManifest?: PagesManifest\n  protected readonly buildId: string\n  protected readonly minimalMode: boolean\n  protected readonly renderOpts: BaseRenderOpts\n  protected readonly serverOptions: Readonly<ServerOptions>\n  protected readonly appPathRoutes?: Record<string, string[]>\n  protected readonly clientReferenceManifest?: DeepReadonly<ClientReferenceManifest>\n  protected interceptionRoutePatterns: RegExp[]\n  protected nextFontManifest?: DeepReadonly<NextFontManifest>\n  protected instrumentation: InstrumentationModule | undefined\n  private readonly responseCache: ResponseCacheBase\n\n  protected abstract getPublicDir(): string\n  protected abstract getHasStaticDir(): boolean\n  protected abstract getPagesManifest(): PagesManifest | undefined\n  protected abstract getAppPathsManifest(): PagesManifest | undefined\n  protected abstract getBuildId(): string\n  protected abstract getinterceptionRoutePatterns(): RegExp[]\n\n  protected readonly enabledDirectories: NextEnabledDirectories\n  protected abstract getEnabledDirectories(dev: boolean): NextEnabledDirectories\n\n  protected readonly experimentalTestProxy?: boolean\n\n  protected abstract findPageComponents(params: {\n    locale: string | undefined\n    page: string\n    query: NextParsedUrlQuery\n    params: Params\n    isAppPath: boolean\n    // The following parameters are used in the development server's\n    // implementation.\n    sriEnabled?: boolean\n    appPaths?: ReadonlyArray<string> | null\n    shouldEnsure?: boolean\n    url?: string\n  }): Promise<FindComponentsResult | null>\n  protected abstract getPrerenderManifest(): DeepReadonly<PrerenderManifest>\n  protected abstract getNextFontManifest():\n    | DeepReadonly<NextFontManifest>\n    | undefined\n  protected abstract attachRequestMeta(\n    req: ServerRequest,\n    parsedUrl: NextUrlWithParsedQuery\n  ): void\n  protected abstract hasPage(pathname: string): Promise<boolean>\n\n  protected abstract sendRenderResult(\n    req: ServerRequest,\n    res: ServerResponse,\n    options: {\n      result: RenderResult\n      type: 'html' | 'json' | 'rsc'\n      generateEtags: boolean\n      poweredByHeader: boolean\n      cacheControl: CacheControl | undefined\n    }\n  ): Promise<void>\n\n  protected abstract runApi(\n    req: ServerRequest,\n    res: ServerResponse,\n    query: ParsedUrlQuery,\n    match: PagesAPIRouteMatch\n  ): Promise<boolean>\n\n  protected abstract renderHTML(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery,\n    renderOpts: LoadedRenderOpts\n  ): Promise<RenderResult>\n\n  protected abstract getIncrementalCache(options: {\n    requestHeaders: Record<string, undefined | string | string[]>\n    requestProtocol: 'http' | 'https'\n  }): Promise<import('./lib/incremental-cache').IncrementalCache>\n\n  protected abstract getResponseCache(options: {\n    dev: boolean\n  }): ResponseCacheBase\n\n  protected getServerComponentsHmrCache():\n    | ServerComponentsHmrCache\n    | undefined {\n    return this.nextConfig.experimental.serverComponentsHmrCache\n      ? (globalThis as any).__serverComponentsHmrCache\n      : undefined\n  }\n\n  protected abstract loadEnvConfig(params: {\n    dev: boolean\n    forceReload?: boolean\n  }): void\n\n  // TODO-APP: (wyattjoh): Make protected again. Used for turbopack in route-resolver.ts right now.\n  public readonly matchers: RouteMatcherManager\n  protected readonly i18nProvider?: I18NProvider\n  protected readonly localeNormalizer?: LocaleRouteNormalizer\n\n  protected readonly normalizers: {\n    readonly rsc: RSCPathnameNormalizer | undefined\n    readonly prefetchRSC: PrefetchRSCPathnameNormalizer | undefined\n    readonly segmentPrefetchRSC: SegmentPrefixRSCPathnameNormalizer | undefined\n    readonly data: NextDataPathnameNormalizer | undefined\n  }\n\n  private readonly isAppPPREnabled: boolean\n  private readonly isAppSegmentPrefetchEnabled: boolean\n\n  /**\n   * This is used to persist cache scopes across\n   * prefetch -> full route requests for dynamic IO\n   * it's only fully used in dev\n   */\n\n  public constructor(options: ServerOptions) {\n    const {\n      dir = '.',\n      quiet = false,\n      conf,\n      dev = false,\n      minimalMode = false,\n      hostname,\n      port,\n      experimentalTestProxy,\n    } = options\n\n    this.experimentalTestProxy = experimentalTestProxy\n    this.serverOptions = options\n\n    this.dir =\n      process.env.NEXT_RUNTIME === 'edge' ? dir : require('path').resolve(dir)\n\n    this.quiet = quiet\n    this.loadEnvConfig({ dev })\n\n    // TODO: should conf be normalized to prevent missing\n    // values from causing issues as this can be user provided\n    this.nextConfig = conf as NextConfigComplete\n    this.hostname = hostname\n    if (this.hostname) {\n      // we format the hostname so that it can be fetched\n      this.fetchHostname = formatHostname(this.hostname)\n    }\n    this.port = port\n    this.distDir =\n      process.env.NEXT_RUNTIME === 'edge'\n        ? this.nextConfig.distDir\n        : require('path').join(this.dir, this.nextConfig.distDir)\n    this.publicDir = this.getPublicDir()\n    this.hasStaticDir = !minimalMode && this.getHasStaticDir()\n\n    this.i18nProvider = this.nextConfig.i18n?.locales\n      ? new I18NProvider(this.nextConfig.i18n)\n      : undefined\n\n    // Configure the locale normalizer, it's used for routes inside `pages/`.\n    this.localeNormalizer = this.i18nProvider\n      ? new LocaleRouteNormalizer(this.i18nProvider)\n      : undefined\n\n    // Only serverRuntimeConfig needs the default\n    // publicRuntimeConfig gets it's default in client/index.js\n    const {\n      serverRuntimeConfig = {},\n      publicRuntimeConfig,\n      assetPrefix,\n      generateEtags,\n    } = this.nextConfig\n\n    this.buildId = this.getBuildId()\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = 'minimalMode'\n    this[minimalModeKey] =\n      minimalMode || !!process.env.NEXT_PRIVATE_MINIMAL_MODE\n\n    this.enabledDirectories = this.getEnabledDirectories(dev)\n\n    this.isAppPPREnabled =\n      this.enabledDirectories.app &&\n      checkIsAppPPREnabled(this.nextConfig.experimental.ppr)\n\n    this.isAppSegmentPrefetchEnabled =\n      this.enabledDirectories.app &&\n      this.nextConfig.experimental.clientSegmentCache === true\n\n    this.normalizers = {\n      // We should normalize the pathname from the RSC prefix only in minimal\n      // mode as otherwise that route is not exposed external to the server as\n      // we instead only rely on the headers.\n      rsc:\n        this.enabledDirectories.app && this.minimalMode\n          ? new RSCPathnameNormalizer()\n          : undefined,\n      prefetchRSC:\n        this.isAppPPREnabled && this.minimalMode\n          ? new PrefetchRSCPathnameNormalizer()\n          : undefined,\n      segmentPrefetchRSC:\n        this.isAppSegmentPrefetchEnabled && this.minimalMode\n          ? new SegmentPrefixRSCPathnameNormalizer()\n          : undefined,\n      data: this.enabledDirectories.pages\n        ? new NextDataPathnameNormalizer(this.buildId)\n        : undefined,\n    }\n\n    this.nextFontManifest = this.getNextFontManifest()\n\n    if (process.env.NEXT_RUNTIME !== 'edge') {\n      process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || ''\n    }\n\n    this.renderOpts = {\n      dir: this.dir,\n      supportsDynamicResponse: true,\n      trailingSlash: this.nextConfig.trailingSlash,\n      deploymentId: this.nextConfig.deploymentId,\n      strictNextHead: this.nextConfig.experimental.strictNextHead ?? true,\n      poweredByHeader: this.nextConfig.poweredByHeader,\n      canonicalBase: this.nextConfig.amp.canonicalBase || '',\n      generateEtags,\n      previewProps: this.getPrerenderManifest().preview,\n      ampOptimizerConfig: this.nextConfig.experimental.amp?.optimizer,\n      basePath: this.nextConfig.basePath,\n      images: this.nextConfig.images,\n      optimizeCss: this.nextConfig.experimental.optimizeCss,\n      nextConfigOutput: this.nextConfig.output,\n      nextScriptWorkers: this.nextConfig.experimental.nextScriptWorkers,\n      disableOptimizedLoading:\n        this.nextConfig.experimental.disableOptimizedLoading,\n      domainLocales: this.nextConfig.i18n?.domains,\n      distDir: this.distDir,\n      serverComponents: this.enabledDirectories.app,\n      cacheLifeProfiles: this.nextConfig.experimental.cacheLife,\n      enableTainting: this.nextConfig.experimental.taint,\n      crossOrigin: this.nextConfig.crossOrigin\n        ? this.nextConfig.crossOrigin\n        : undefined,\n      largePageDataBytes: this.nextConfig.experimental.largePageDataBytes,\n      // Only the `publicRuntimeConfig` key is exposed to the client side\n      // It'll be rendered as part of __NEXT_DATA__ on the client side\n      runtimeConfig:\n        Object.keys(publicRuntimeConfig).length > 0\n          ? publicRuntimeConfig\n          : undefined,\n\n      isExperimentalCompile: this.nextConfig.experimental.isExperimentalCompile,\n      // `htmlLimitedBots` is passed to server as serialized config in string format\n      htmlLimitedBots: this.nextConfig.htmlLimitedBots,\n      experimental: {\n        expireTime: this.nextConfig.expireTime,\n        staleTimes: this.nextConfig.experimental.staleTimes,\n        clientTraceMetadata: this.nextConfig.experimental.clientTraceMetadata,\n        dynamicIO: this.nextConfig.experimental.dynamicIO ?? false,\n        clientSegmentCache:\n          this.nextConfig.experimental.clientSegmentCache === 'client-only'\n            ? 'client-only'\n            : Boolean(this.nextConfig.experimental.clientSegmentCache),\n        dynamicOnHover: this.nextConfig.experimental.dynamicOnHover ?? false,\n        inlineCss: this.nextConfig.experimental.inlineCss ?? false,\n        authInterrupts: !!this.nextConfig.experimental.authInterrupts,\n      },\n      onInstrumentationRequestError:\n        this.instrumentationOnRequestError.bind(this),\n      reactMaxHeadersLength: this.nextConfig.reactMaxHeadersLength,\n      devtoolSegmentExplorer:\n        this.nextConfig.experimental.devtoolSegmentExplorer,\n    }\n\n    // Initialize next/config with the environment configuration\n    setConfig({\n      serverRuntimeConfig,\n      publicRuntimeConfig,\n    })\n\n    this.pagesManifest = this.getPagesManifest()\n    this.appPathsManifest = this.getAppPathsManifest()\n    this.appPathRoutes = this.getAppPathRoutes()\n    this.interceptionRoutePatterns = this.getinterceptionRoutePatterns()\n\n    // Configure the routes.\n    this.matchers = this.getRouteMatchers()\n\n    // Start route compilation. We don't wait for the routes to finish loading\n    // because we use the `waitTillReady` promise below in `handleRequest` to\n    // wait. Also we can't `await` in the constructor.\n    void this.matchers.reload()\n\n    this.setAssetPrefix(assetPrefix)\n    this.responseCache = this.getResponseCache({ dev })\n  }\n\n  protected reloadMatchers() {\n    return this.matchers.reload()\n  }\n\n  private handleRSCRequest: RouteHandler<ServerRequest, ServerResponse> = (\n    req,\n    _res,\n    parsedUrl\n  ) => {\n    if (!parsedUrl.pathname) return false\n\n    if (this.normalizers.segmentPrefetchRSC?.match(parsedUrl.pathname)) {\n      const result = this.normalizers.segmentPrefetchRSC.extract(\n        parsedUrl.pathname\n      )\n      if (!result) return false\n\n      const { originalPathname, segmentPath } = result\n      parsedUrl.pathname = originalPathname\n\n      // Mark the request as a router prefetch request.\n      req.headers[RSC_HEADER.toLowerCase()] = '1'\n      req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] = '1'\n      req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()] =\n        segmentPath\n\n      addRequestMeta(req, 'isRSCRequest', true)\n      addRequestMeta(req, 'isPrefetchRSCRequest', true)\n      addRequestMeta(req, 'segmentPrefetchRSCRequest', segmentPath)\n    } else if (this.normalizers.prefetchRSC?.match(parsedUrl.pathname)) {\n      parsedUrl.pathname = this.normalizers.prefetchRSC.normalize(\n        parsedUrl.pathname,\n        true\n      )\n\n      // Mark the request as a router prefetch request.\n      req.headers[RSC_HEADER.toLowerCase()] = '1'\n      req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] = '1'\n      addRequestMeta(req, 'isRSCRequest', true)\n      addRequestMeta(req, 'isPrefetchRSCRequest', true)\n    } else if (this.normalizers.rsc?.match(parsedUrl.pathname)) {\n      parsedUrl.pathname = this.normalizers.rsc.normalize(\n        parsedUrl.pathname,\n        true\n      )\n\n      // Mark the request as a RSC request.\n      req.headers[RSC_HEADER.toLowerCase()] = '1'\n      addRequestMeta(req, 'isRSCRequest', true)\n    } else if (req.headers['x-now-route-matches']) {\n      // If we didn't match, return with the flight headers stripped. If in\n      // minimal mode we didn't match based on the path, this can't be a RSC\n      // request. This is because Vercel only sends this header during\n      // revalidation requests and we want the cache to instead depend on the\n      // request path for flight information.\n      stripFlightHeaders(req.headers)\n\n      return false\n    } else if (req.headers[RSC_HEADER.toLowerCase()] === '1') {\n      addRequestMeta(req, 'isRSCRequest', true)\n\n      if (req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] === '1') {\n        addRequestMeta(req, 'isPrefetchRSCRequest', true)\n\n        const segmentPrefetchRSCRequest =\n          req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()]\n        if (typeof segmentPrefetchRSCRequest === 'string') {\n          addRequestMeta(\n            req,\n            'segmentPrefetchRSCRequest',\n            segmentPrefetchRSCRequest\n          )\n        }\n      }\n    } else {\n      // Otherwise just return without doing anything.\n      return false\n    }\n\n    if (req.url) {\n      const parsed = parseUrl(req.url)\n      parsed.pathname = parsedUrl.pathname\n      req.url = formatUrl(parsed)\n    }\n\n    return false\n  }\n\n  private handleNextDataRequest: RouteHandler<ServerRequest, ServerResponse> =\n    async (req, res, parsedUrl) => {\n      const middleware = await this.getMiddleware()\n      const params = matchNextDataPathname(parsedUrl.pathname)\n\n      // ignore for non-next data URLs\n      if (!params || !params.path) {\n        return false\n      }\n\n      if (params.path[0] !== this.buildId) {\n        // Ignore if its a middleware request when we aren't on edge.\n        if (\n          process.env.NEXT_RUNTIME !== 'edge' &&\n          getRequestMeta(req, 'middlewareInvoke')\n        ) {\n          return false\n        }\n\n        // Make sure to 404 if the buildId isn't correct\n        await this.render404(req, res, parsedUrl)\n        return true\n      }\n\n      // remove buildId from URL\n      params.path.shift()\n\n      const lastParam = params.path[params.path.length - 1]\n\n      // show 404 if it doesn't end with .json\n      if (typeof lastParam !== 'string' || !lastParam.endsWith('.json')) {\n        await this.render404(req, res, parsedUrl)\n        return true\n      }\n\n      // re-create page's pathname\n      let pathname = `/${params.path.join('/')}`\n      pathname = getRouteFromAssetPath(pathname, '.json')\n\n      // ensure trailing slash is normalized per config\n      if (middleware) {\n        if (this.nextConfig.trailingSlash && !pathname.endsWith('/')) {\n          pathname += '/'\n        }\n        if (\n          !this.nextConfig.trailingSlash &&\n          pathname.length > 1 &&\n          pathname.endsWith('/')\n        ) {\n          pathname = pathname.substring(0, pathname.length - 1)\n        }\n      }\n\n      if (this.i18nProvider) {\n        // Remove the port from the hostname if present.\n        const hostname = req?.headers.host?.split(':', 1)[0].toLowerCase()\n\n        const domainLocale = this.i18nProvider.detectDomainLocale(hostname)\n        const defaultLocale =\n          domainLocale?.defaultLocale ?? this.i18nProvider.config.defaultLocale\n\n        const localePathResult = this.i18nProvider.analyze(pathname)\n\n        // If the locale is detected from the path, we need to remove it\n        // from the pathname.\n        if (localePathResult.detectedLocale) {\n          pathname = localePathResult.pathname\n        }\n\n        // Update the query with the detected locale and default locale.\n        addRequestMeta(req, 'locale', localePathResult.detectedLocale)\n        addRequestMeta(req, 'defaultLocale', defaultLocale)\n\n        // If the locale is not detected from the path, we need to mark that\n        // it was not inferred from default.\n        if (!localePathResult.detectedLocale) {\n          removeRequestMeta(req, 'localeInferredFromDefault')\n        }\n\n        // If no locale was detected and we don't have middleware, we need\n        // to render a 404 page.\n        if (!localePathResult.detectedLocale && !middleware) {\n          addRequestMeta(req, 'locale', defaultLocale)\n          await this.render404(req, res, parsedUrl)\n          return true\n        }\n      }\n\n      parsedUrl.pathname = pathname\n      addRequestMeta(req, 'isNextDataReq', true)\n\n      return false\n    }\n\n  protected handleNextImageRequest: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = () => false\n\n  protected handleCatchallRenderRequest: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = () => false\n\n  protected handleCatchallMiddlewareRequest: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = () => false\n\n  protected getRouteMatchers(): RouteMatcherManager {\n    // Create a new manifest loader that get's the manifests from the server.\n    const manifestLoader = new ServerManifestLoader((name) => {\n      switch (name) {\n        case PAGES_MANIFEST:\n          return this.getPagesManifest() ?? null\n        case APP_PATHS_MANIFEST:\n          return this.getAppPathsManifest() ?? null\n        default:\n          return null\n      }\n    })\n\n    // Configure the matchers and handlers.\n    const matchers: RouteMatcherManager = new DefaultRouteMatcherManager()\n\n    // Match pages under `pages/`.\n    matchers.push(\n      new PagesRouteMatcherProvider(\n        this.distDir,\n        manifestLoader,\n        this.i18nProvider\n      )\n    )\n\n    // Match api routes under `pages/api/`.\n    matchers.push(\n      new PagesAPIRouteMatcherProvider(\n        this.distDir,\n        manifestLoader,\n        this.i18nProvider\n      )\n    )\n\n    // If the app directory is enabled, then add the app matchers and handlers.\n    if (this.enabledDirectories.app) {\n      // Match app pages under `app/`.\n      matchers.push(\n        new AppPageRouteMatcherProvider(this.distDir, manifestLoader)\n      )\n      matchers.push(\n        new AppRouteRouteMatcherProvider(this.distDir, manifestLoader)\n      )\n    }\n\n    return matchers\n  }\n\n  protected async instrumentationOnRequestError(\n    ...args: Parameters<ServerOnInstrumentationRequestError>\n  ) {\n    const [err, req, ctx] = args\n\n    if (this.instrumentation) {\n      try {\n        await this.instrumentation.onRequestError?.(\n          err,\n          {\n            path: req.url || '',\n            method: req.method || 'GET',\n            // Normalize middleware headers and other server request headers\n            headers:\n              req instanceof NextRequestHint\n                ? Object.fromEntries(req.headers.entries())\n                : req.headers,\n          },\n          ctx\n        )\n      } catch (handlerErr) {\n        // Log the soft error and continue, since errors can thrown from react stream handler\n        console.error('Error in instrumentation.onRequestError:', handlerErr)\n      }\n    }\n  }\n\n  public logError(err: Error): void {\n    if (this.quiet) return\n    Log.error(err)\n  }\n\n  public async handleRequest(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    await this.prepare()\n    const method = req.method.toUpperCase()\n\n    const tracer = getTracer()\n    return tracer.withPropagatedContext(req.headers, () => {\n      return tracer.trace(\n        BaseServerSpan.handleRequest,\n        {\n          spanName: `${method} ${req.url}`,\n          kind: SpanKind.SERVER,\n          attributes: {\n            'http.method': method,\n            'http.target': req.url,\n          },\n        },\n        async (span) =>\n          this.handleRequestImpl(req, res, parsedUrl).finally(() => {\n            if (!span) return\n\n            const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false\n            span.setAttributes({\n              'http.status_code': res.statusCode,\n              'next.rsc': isRSCRequest,\n            })\n\n            const rootSpanAttributes = tracer.getRootSpanAttributes()\n            // We were unable to get attributes, probably OTEL is not enabled\n            if (!rootSpanAttributes) return\n\n            if (\n              rootSpanAttributes.get('next.span_type') !==\n              BaseServerSpan.handleRequest\n            ) {\n              console.warn(\n                `Unexpected root span type '${rootSpanAttributes.get(\n                  'next.span_type'\n                )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n              )\n              return\n            }\n\n            const route = rootSpanAttributes.get('next.route')\n            if (route) {\n              const name = isRSCRequest\n                ? `RSC ${method} ${route}`\n                : `${method} ${route}`\n\n              span.setAttributes({\n                'next.route': route,\n                'http.route': route,\n                'next.span_name': name,\n              })\n              span.updateName(name)\n            } else {\n              span.updateName(\n                isRSCRequest\n                  ? `RSC ${method} ${req.url}`\n                  : `${method} ${req.url}`\n              )\n            }\n          })\n      )\n    })\n  }\n\n  private async handleRequestImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    try {\n      // Wait for the matchers to be ready.\n      await this.matchers.waitTillReady()\n\n      // ensure cookies set in middleware are merged and\n      // not overridden by API routes/getServerSideProps\n      patchSetHeaderWithCookieSupport(\n        req,\n        isNodeNextResponse(res) ? res.originalResponse : res\n      )\n\n      const urlParts = (req.url || '').split('?', 1)\n      const urlNoQuery = urlParts[0]\n\n      // this normalizes repeated slashes in the path e.g. hello//world ->\n      // hello/world or backslashes to forward slashes, this does not\n      // handle trailing slash as that is handled the same as a next.config.js\n      // redirect\n      if (urlNoQuery?.match(/(\\\\|\\/\\/)/)) {\n        const cleanUrl = normalizeRepeatedSlashes(req.url!)\n        res.redirect(cleanUrl, 308).body(cleanUrl).send()\n        return\n      }\n\n      // Parse url if parsedUrl not provided\n      if (!parsedUrl || typeof parsedUrl !== 'object') {\n        if (!req.url) {\n          throw new Error('Invariant: url can not be undefined')\n        }\n\n        parsedUrl = parseUrl(req.url!, true)\n      }\n\n      if (!parsedUrl.pathname) {\n        throw new Error(\"Invariant: pathname can't be empty\")\n      }\n\n      // Parse the querystring ourselves if the user doesn't handle querystring parsing\n      if (typeof parsedUrl.query === 'string') {\n        parsedUrl.query = Object.fromEntries(\n          new URLSearchParams(parsedUrl.query)\n        )\n      }\n\n      // Update the `x-forwarded-*` headers.\n      const { originalRequest = null } = isNodeNextRequest(req) ? req : {}\n      const xForwardedProto = originalRequest?.headers['x-forwarded-proto']\n      const isHttps = xForwardedProto\n        ? xForwardedProto === 'https'\n        : !!(originalRequest?.socket as TLSSocket)?.encrypted\n\n      req.headers['x-forwarded-host'] ??= req.headers['host'] ?? this.hostname\n      req.headers['x-forwarded-port'] ??= this.port\n        ? this.port.toString()\n        : isHttps\n          ? '443'\n          : '80'\n      req.headers['x-forwarded-proto'] ??= isHttps ? 'https' : 'http'\n      req.headers['x-forwarded-for'] ??= originalRequest?.socket?.remoteAddress\n\n      // This should be done before any normalization of the pathname happens as\n      // it captures the initial URL.\n      this.attachRequestMeta(req, parsedUrl)\n\n      let finished = await this.handleRSCRequest(req, res, parsedUrl)\n      if (finished) return\n\n      const domainLocale = this.i18nProvider?.detectDomainLocale(\n        getHostname(parsedUrl, req.headers)\n      )\n\n      const defaultLocale =\n        domainLocale?.defaultLocale || this.nextConfig.i18n?.defaultLocale\n      addRequestMeta(req, 'defaultLocale', defaultLocale)\n\n      const url = parseUrlUtil(req.url.replace(/^\\/+/, '/'))\n      const pathnameInfo = getNextPathnameInfo(url.pathname, {\n        nextConfig: this.nextConfig,\n        i18nProvider: this.i18nProvider,\n      })\n      url.pathname = pathnameInfo.pathname\n\n      if (pathnameInfo.basePath) {\n        req.url = removePathPrefix(req.url!, this.nextConfig.basePath)\n      }\n\n      const useMatchedPathHeader =\n        this.minimalMode && typeof req.headers[MATCHED_PATH_HEADER] === 'string'\n\n      // TODO: merge handling with invokePath\n      if (useMatchedPathHeader) {\n        try {\n          if (this.enabledDirectories.app) {\n            // ensure /index path is normalized for prerender\n            // in minimal mode\n            if (req.url.match(/^\\/index($|\\?)/)) {\n              req.url = req.url.replace(/^\\/index/, '/')\n            }\n            parsedUrl.pathname =\n              parsedUrl.pathname === '/index' ? '/' : parsedUrl.pathname\n          }\n\n          // x-matched-path is the source of truth, it tells what page\n          // should be rendered because we don't process rewrites in minimalMode\n          let { pathname: matchedPath } = new URL(\n            fixMojibake(req.headers[MATCHED_PATH_HEADER] as string),\n            'http://localhost'\n          )\n\n          let { pathname: urlPathname } = new URL(req.url, 'http://localhost')\n\n          // For ISR the URL is normalized to the prerenderPath so if\n          // it's a data request the URL path will be the data URL,\n          // basePath is already stripped by this point\n          if (this.normalizers.data?.match(urlPathname)) {\n            addRequestMeta(req, 'isNextDataReq', true)\n          }\n          // In minimal mode, if PPR is enabled, then we should check to see if\n          // the request should be a resume request.\n          else if (\n            this.isAppPPREnabled &&\n            this.minimalMode &&\n            req.headers[NEXT_RESUME_HEADER] === '1' &&\n            req.method === 'POST'\n          ) {\n            // Decode the postponed state from the request body, it will come as\n            // an array of buffers, so collect them and then concat them to form\n            // the string.\n            const body: Array<Buffer> = []\n            for await (const chunk of req.body) {\n              body.push(chunk)\n            }\n            const postponed = Buffer.concat(body).toString('utf8')\n\n            addRequestMeta(req, 'postponed', postponed)\n          }\n\n          matchedPath = this.normalize(matchedPath)\n          const normalizedUrlPath = this.stripNextDataPath(urlPathname)\n\n          matchedPath = denormalizePagePath(matchedPath)\n\n          // Perform locale detection and normalization.\n          const localeAnalysisResult = this.i18nProvider?.analyze(matchedPath, {\n            defaultLocale,\n          })\n\n          // The locale result will be defined even if the locale was not\n          // detected for the request because it will be inferred from the\n          // default locale.\n          if (localeAnalysisResult) {\n            addRequestMeta(req, 'locale', localeAnalysisResult.detectedLocale)\n\n            // If the detected locale was inferred from the default locale, we\n            // need to modify the metadata on the request to indicate that.\n            if (localeAnalysisResult.inferredFromDefault) {\n              addRequestMeta(req, 'localeInferredFromDefault', true)\n            } else {\n              removeRequestMeta(req, 'localeInferredFromDefault')\n            }\n          }\n\n          let srcPathname = matchedPath\n          let pageIsDynamic = isDynamicRoute(srcPathname)\n          let paramsResult: {\n            params: ParsedUrlQuery | false\n            hasValidParams: boolean\n          } = {\n            params: false,\n            hasValidParams: false,\n          }\n\n          if (!pageIsDynamic) {\n            const match = await this.matchers.match(srcPathname, {\n              i18n: localeAnalysisResult,\n            })\n\n            // Update the source pathname to the matched page's pathname.\n            if (match) {\n              srcPathname = match.definition.pathname\n\n              // The page is dynamic if the params are defined. We know at this\n              // stage that the matched path is not a static page if the params\n              // were parsed from the matched path header.\n              if (typeof match.params !== 'undefined') {\n                pageIsDynamic = true\n                paramsResult.params = match.params\n                paramsResult.hasValidParams = true\n              }\n            }\n          }\n\n          // The rest of this function can't handle i18n properly, so ensure we\n          // restore the pathname with the locale information stripped from it\n          // now that we're done matching if we're using i18n.\n          if (localeAnalysisResult) {\n            matchedPath = localeAnalysisResult.pathname\n          }\n\n          const utils = getServerUtils({\n            pageIsDynamic,\n            page: srcPathname,\n            i18n: this.nextConfig.i18n,\n            basePath: this.nextConfig.basePath,\n            rewrites: this.getRoutesManifest()?.rewrites || {\n              beforeFiles: [],\n              afterFiles: [],\n              fallback: [],\n            },\n            caseSensitive: !!this.nextConfig.experimental.caseSensitiveRoutes,\n          })\n\n          // Ensure parsedUrl.pathname includes locale before processing\n          // rewrites or they won't match correctly.\n          if (defaultLocale && !pathnameInfo.locale) {\n            parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname}`\n          }\n\n          // Store a copy of `parsedUrl.query` before calling handleRewrites.\n          // Since `handleRewrites` might add new queries to `parsedUrl.query`.\n          const originQueryParams = { ...parsedUrl.query }\n\n          const pathnameBeforeRewrite = parsedUrl.pathname\n          const rewriteParamKeys = Object.keys(\n            utils.handleRewrites(req, parsedUrl)\n          )\n\n          // Create a copy of the query params to avoid mutating the original\n          // object. This prevents any overlapping query params that have the\n          // same normalized key from causing issues.\n          const queryParams = { ...parsedUrl.query }\n          const didRewrite = pathnameBeforeRewrite !== parsedUrl.pathname\n\n          if (didRewrite && parsedUrl.pathname) {\n            addRequestMeta(req, 'rewroteURL', parsedUrl.pathname)\n          }\n\n          const routeParamKeys = new Set<string>()\n          for (const [key, value] of Object.entries(parsedUrl.query)) {\n            const normalizedKey = normalizeNextQueryParam(key)\n            if (!normalizedKey) continue\n\n            // Remove the prefixed key from the query params because we want\n            // to consume it for the dynamic route matcher.\n            delete parsedUrl.query[key]\n            routeParamKeys.add(normalizedKey)\n\n            if (typeof value === 'undefined') continue\n\n            queryParams[normalizedKey] = Array.isArray(value)\n              ? value.map((v) => decodeQueryPathParameter(v))\n              : decodeQueryPathParameter(value)\n          }\n\n          // interpolate dynamic params and normalize URL if needed\n          if (pageIsDynamic) {\n            let params: ParsedUrlQuery | false = {}\n\n            // If we don't already have valid params, try to parse them from\n            // the query params.\n            if (!paramsResult.hasValidParams) {\n              paramsResult = utils.normalizeDynamicRouteParams(\n                queryParams,\n                false\n              )\n            }\n\n            // for prerendered ISR paths we attempt parsing the route\n            // params from the URL directly as route-matches may not\n            // contain the correct values due to the filesystem path\n            // matching before the dynamic route has been matched\n            if (\n              !paramsResult.hasValidParams &&\n              !isDynamicRoute(normalizedUrlPath)\n            ) {\n              let matcherParams = utils.dynamicRouteMatcher?.(normalizedUrlPath)\n\n              if (matcherParams) {\n                utils.normalizeDynamicRouteParams(matcherParams, false)\n                Object.assign(paramsResult.params, matcherParams)\n                paramsResult.hasValidParams = true\n              }\n            }\n\n            // if an action request is bypassing a prerender and we\n            // don't have the params in the URL since it was prerendered\n            // and matched during handle: 'filesystem' rather than dynamic route\n            // resolving we need to parse the params from the matched-path.\n            // Note: this is similar to above case but from match-path instead\n            // of from the request URL since a rewrite could cause that to not\n            // match the src pathname\n            if (\n              // we can have a collision with /index and a top-level /[slug]\n              matchedPath !== '/index' &&\n              !paramsResult.hasValidParams &&\n              !isDynamicRoute(matchedPath)\n            ) {\n              let matcherParams = utils.dynamicRouteMatcher?.(matchedPath)\n\n              if (matcherParams) {\n                const curParamsResult = utils.normalizeDynamicRouteParams(\n                  matcherParams,\n                  false\n                )\n\n                if (curParamsResult.hasValidParams) {\n                  Object.assign(params, matcherParams)\n                  paramsResult = curParamsResult\n                }\n              }\n            }\n\n            if (paramsResult.hasValidParams) {\n              params = paramsResult.params\n            }\n\n            const routeMatchesHeader = req.headers['x-now-route-matches']\n            if (\n              typeof routeMatchesHeader === 'string' &&\n              routeMatchesHeader &&\n              isDynamicRoute(matchedPath) &&\n              !paramsResult.hasValidParams\n            ) {\n              const routeMatches =\n                utils.getParamsFromRouteMatches(routeMatchesHeader)\n\n              if (routeMatches) {\n                paramsResult = utils.normalizeDynamicRouteParams(\n                  routeMatches,\n                  true\n                )\n\n                if (paramsResult.hasValidParams) {\n                  params = paramsResult.params\n                }\n              }\n            }\n\n            // Try to parse the params from the query if we couldn't parse them\n            // from the route matches but ignore missing optional params.\n            if (!paramsResult.hasValidParams) {\n              paramsResult = utils.normalizeDynamicRouteParams(\n                queryParams,\n                true\n              )\n\n              if (paramsResult.hasValidParams) {\n                params = paramsResult.params\n              }\n            }\n\n            // If the pathname being requested is the same as the source\n            // pathname, and we don't have valid params, we want to use the\n            // default route matches.\n            if (\n              utils.defaultRouteMatches &&\n              normalizedUrlPath === srcPathname &&\n              !paramsResult.hasValidParams\n            ) {\n              params = utils.defaultRouteMatches\n\n              // If the route matches header is an empty string, we want to\n              // render a fallback shell. This is because we know this came from\n              // a prerender (it has the header) but it's values were filtered\n              // out (because the allowQuery was empty). If it was undefined\n              // then we know that the request is hitting the lambda directly.\n              if (routeMatchesHeader === '') {\n                addRequestMeta(req, 'renderFallbackShell', true)\n              }\n            }\n\n            if (params) {\n              matchedPath = utils.interpolateDynamicPath(srcPathname, params)\n              req.url = utils.interpolateDynamicPath(req.url!, params)\n\n              // If the request is for a segment prefetch, we need to update the\n              // segment prefetch request path to include the interpolated\n              // params.\n              let segmentPrefetchRSCRequest = getRequestMeta(\n                req,\n                'segmentPrefetchRSCRequest'\n              )\n              if (\n                segmentPrefetchRSCRequest &&\n                isDynamicRoute(segmentPrefetchRSCRequest, false)\n              ) {\n                segmentPrefetchRSCRequest = utils.interpolateDynamicPath(\n                  segmentPrefetchRSCRequest,\n                  params\n                )\n\n                req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()] =\n                  segmentPrefetchRSCRequest\n                addRequestMeta(\n                  req,\n                  'segmentPrefetchRSCRequest',\n                  segmentPrefetchRSCRequest\n                )\n              }\n            }\n          }\n\n          if (pageIsDynamic || didRewrite) {\n            utils.normalizeCdnUrl(req, [\n              ...rewriteParamKeys,\n              ...Object.keys(utils.defaultRouteRegex?.groups || {}),\n            ])\n          }\n          // Remove the route `params` keys from `parsedUrl.query` if they are\n          // not in the original query params.\n          // If it's used in both route `params` and query `searchParams`, it should be kept.\n          for (const key of routeParamKeys) {\n            if (!(key in originQueryParams)) {\n              delete parsedUrl.query[key]\n            }\n          }\n          parsedUrl.pathname = matchedPath\n          url.pathname = parsedUrl.pathname\n          finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)\n          if (finished) return\n        } catch (err) {\n          if (err instanceof DecodeError || err instanceof NormalizeError) {\n            res.statusCode = 400\n            return this.renderError(null, req, res, '/_error', {})\n          }\n          throw err\n        }\n      }\n\n      addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))\n\n      if (pathnameInfo.locale) {\n        req.url = formatUrl(url)\n        addRequestMeta(req, 'didStripLocale', true)\n      }\n\n      // If we aren't in minimal mode or there is no locale in the query\n      // string, add the locale to the query string.\n      if (!this.minimalMode || !getRequestMeta(req, 'locale')) {\n        // If the locale is in the pathname, add it to the query string.\n        if (pathnameInfo.locale) {\n          addRequestMeta(req, 'locale', pathnameInfo.locale)\n        }\n        // If the default locale is available, add it to the query string and\n        // mark it as inferred rather than implicit.\n        else if (defaultLocale) {\n          addRequestMeta(req, 'locale', defaultLocale)\n          addRequestMeta(req, 'localeInferredFromDefault', true)\n        }\n      }\n\n      // set incremental cache to request meta so it can\n      // be passed down for edge functions and the fetch disk\n      // cache can be leveraged locally\n      if (\n        !(this.serverOptions as any).webServerConfig &&\n        !getRequestMeta(req, 'incrementalCache')\n      ) {\n        let protocol: 'http:' | 'https:' = 'https:'\n\n        try {\n          const parsedFullUrl = new URL(\n            getRequestMeta(req, 'initURL') || '/',\n            'http://n'\n          )\n          protocol = parsedFullUrl.protocol as 'https:' | 'http:'\n        } catch {}\n\n        const incrementalCache = await this.getIncrementalCache({\n          requestHeaders: Object.assign({}, req.headers),\n          requestProtocol: protocol.substring(0, protocol.length - 1) as\n            | 'http'\n            | 'https',\n        })\n\n        incrementalCache.resetRequestCache()\n        addRequestMeta(req, 'incrementalCache', incrementalCache)\n        // This is needed for pages router to leverage unstable_cache\n        // TODO: re-work this handling to not use global and use a AsyncStore\n        ;(globalThis as any).__incrementalCache = incrementalCache\n      }\n\n      const cacheHandlers = getCacheHandlers()\n\n      if (cacheHandlers) {\n        await Promise.all(\n          [...cacheHandlers].map(async (cacheHandler) => {\n            if ('refreshTags' in cacheHandler) {\n              // Note: cacheHandler.refreshTags() is called lazily before the\n              // first cache entry is retrieved. It allows us to skip the\n              // refresh request if no caches are read at all.\n            } else {\n              const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(\n                req.headers,\n                this.getPrerenderManifest().preview.previewModeId\n              )\n\n              await cacheHandler.receiveExpiredTags(\n                ...previouslyRevalidatedTags\n              )\n            }\n          })\n        )\n      }\n\n      // set server components HMR cache to request meta so it can be passed\n      // down for edge functions\n      if (!getRequestMeta(req, 'serverComponentsHmrCache')) {\n        addRequestMeta(\n          req,\n          'serverComponentsHmrCache',\n          this.getServerComponentsHmrCache()\n        )\n      }\n\n      // when invokePath is specified we can short short circuit resolving\n      // we only honor this header if we are inside of a render worker to\n      // prevent external users coercing the routing path\n      const invokePath = getRequestMeta(req, 'invokePath')\n      const useInvokePath =\n        !useMatchedPathHeader &&\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        invokePath\n\n      if (useInvokePath) {\n        const invokeStatus = getRequestMeta(req, 'invokeStatus')\n        if (invokeStatus) {\n          const invokeQuery = getRequestMeta(req, 'invokeQuery')\n\n          if (invokeQuery) {\n            Object.assign(parsedUrl.query, invokeQuery)\n          }\n\n          res.statusCode = invokeStatus\n          let err: Error | null = getRequestMeta(req, 'invokeError') || null\n\n          return this.renderError(err, req, res, '/_error', parsedUrl.query)\n        }\n\n        const parsedMatchedPath = new URL(invokePath || '/', 'http://n')\n        const invokePathnameInfo = getNextPathnameInfo(\n          parsedMatchedPath.pathname,\n          {\n            nextConfig: this.nextConfig,\n            parseData: false,\n          }\n        )\n\n        if (invokePathnameInfo.locale) {\n          addRequestMeta(req, 'locale', invokePathnameInfo.locale)\n        }\n\n        if (parsedUrl.pathname !== parsedMatchedPath.pathname) {\n          parsedUrl.pathname = parsedMatchedPath.pathname\n          addRequestMeta(req, 'rewroteURL', invokePathnameInfo.pathname)\n        }\n        const normalizeResult = normalizeLocalePath(\n          removePathPrefix(parsedUrl.pathname, this.nextConfig.basePath || ''),\n          this.nextConfig.i18n?.locales\n        )\n\n        if (normalizeResult.detectedLocale) {\n          addRequestMeta(req, 'locale', normalizeResult.detectedLocale)\n        }\n        parsedUrl.pathname = normalizeResult.pathname\n\n        for (const key of Object.keys(parsedUrl.query)) {\n          delete parsedUrl.query[key]\n        }\n        const invokeQuery = getRequestMeta(req, 'invokeQuery')\n\n        if (invokeQuery) {\n          Object.assign(parsedUrl.query, invokeQuery)\n        }\n\n        finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)\n        if (finished) return\n\n        await this.handleCatchallRenderRequest(req, res, parsedUrl)\n        return\n      }\n\n      if (\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        getRequestMeta(req, 'middlewareInvoke')\n      ) {\n        finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl)\n        if (finished) return\n\n        finished = await this.handleCatchallMiddlewareRequest(\n          req,\n          res,\n          parsedUrl\n        )\n        if (finished) return\n\n        const err = new Error()\n        ;(err as any).result = {\n          response: new Response(null, {\n            headers: {\n              'x-middleware-next': '1',\n            },\n          }),\n        }\n        ;(err as any).bubble = true\n        throw err\n      }\n\n      // This wasn't a request via the matched path or the invoke path, so\n      // prepare for a legacy run by removing the base path.\n\n      // ensure we strip the basePath when not using an invoke header\n      if (!useMatchedPathHeader && pathnameInfo.basePath) {\n        parsedUrl.pathname = removePathPrefix(\n          parsedUrl.pathname,\n          pathnameInfo.basePath\n        )\n      }\n\n      res.statusCode = 200\n      return await this.run(req, res, parsedUrl)\n    } catch (err: any) {\n      if (err instanceof NoFallbackError) {\n        throw err\n      }\n\n      if (\n        (err && typeof err === 'object' && err.code === 'ERR_INVALID_URL') ||\n        err instanceof DecodeError ||\n        err instanceof NormalizeError\n      ) {\n        res.statusCode = 400\n        return this.renderError(null, req, res, '/_error', {})\n      }\n\n      if (\n        this.minimalMode ||\n        this.renderOpts.dev ||\n        (isBubbledError(err) && err.bubble)\n      ) {\n        throw err\n      }\n      this.logError(getProperError(err))\n      res.statusCode = 500\n      res.body('Internal Server Error').send()\n    }\n  }\n\n  /**\n   * Normalizes a pathname without attaching any metadata from any matched\n   * normalizer.\n   *\n   * @param pathname the pathname to normalize\n   * @returns the normalized pathname\n   */\n  private normalize = (pathname: string) => {\n    const normalizers: Array<PathnameNormalizer> = []\n\n    if (this.normalizers.data) {\n      normalizers.push(this.normalizers.data)\n    }\n\n    // We have to put the segment prefetch normalizer before the RSC normalizer\n    // because the RSC normalizer will match the prefetch RSC routes too.\n    if (this.normalizers.segmentPrefetchRSC) {\n      normalizers.push(this.normalizers.segmentPrefetchRSC)\n    }\n\n    // We have to put the prefetch normalizer before the RSC normalizer\n    // because the RSC normalizer will match the prefetch RSC routes too.\n    if (this.normalizers.prefetchRSC) {\n      normalizers.push(this.normalizers.prefetchRSC)\n    }\n\n    if (this.normalizers.rsc) {\n      normalizers.push(this.normalizers.rsc)\n    }\n\n    for (const normalizer of normalizers) {\n      if (!normalizer.match(pathname)) continue\n\n      return normalizer.normalize(pathname, true)\n    }\n\n    return pathname\n  }\n\n  private normalizeAndAttachMetadata: RouteHandler<\n    ServerRequest,\n    ServerResponse\n  > = async (req, res, url) => {\n    let finished = await this.handleNextImageRequest(req, res, url)\n    if (finished) return true\n\n    if (this.enabledDirectories.pages) {\n      finished = await this.handleNextDataRequest(req, res, url)\n      if (finished) return true\n    }\n\n    return false\n  }\n\n  /**\n   * @internal - this method is internal to Next.js and should not be used directly by end-users\n   */\n  public getRequestHandlerWithMetadata(\n    meta: RequestMeta\n  ): BaseRequestHandler<ServerRequest, ServerResponse> {\n    const handler = this.getRequestHandler()\n    return (req, res, parsedUrl) => {\n      setRequestMeta(req, meta)\n      return handler(req, res, parsedUrl)\n    }\n  }\n\n  public getRequestHandler(): BaseRequestHandler<\n    ServerRequest,\n    ServerResponse\n  > {\n    return this.handleRequest.bind(this)\n  }\n\n  protected abstract handleUpgrade(\n    req: ServerRequest,\n    socket: any,\n    head?: any\n  ): Promise<void>\n\n  public setAssetPrefix(prefix?: string): void {\n    this.renderOpts.assetPrefix = prefix ? prefix.replace(/\\/$/, '') : ''\n  }\n\n  protected prepared: boolean = false\n  protected preparedPromise: Promise<void> | null = null\n  /**\n   * Runs async initialization of server.\n   * It is idempotent, won't fire underlying initialization more than once.\n   */\n  public async prepare(): Promise<void> {\n    if (this.prepared) return\n\n    // Get instrumentation module\n    if (!this.instrumentation) {\n      this.instrumentation = await this.loadInstrumentationModule()\n    }\n    if (this.preparedPromise === null) {\n      this.preparedPromise = this.prepareImpl().then(() => {\n        this.prepared = true\n        this.preparedPromise = null\n      })\n    }\n    return this.preparedPromise\n  }\n  protected async prepareImpl(): Promise<void> {}\n  protected async loadInstrumentationModule(): Promise<any> {}\n\n  public async close(): Promise<void> {}\n\n  protected getAppPathRoutes(): Record<string, string[]> {\n    const appPathRoutes: Record<string, string[]> = {}\n\n    Object.keys(this.appPathsManifest || {}).forEach((entry) => {\n      const normalizedPath = normalizeAppPath(entry)\n      if (!appPathRoutes[normalizedPath]) {\n        appPathRoutes[normalizedPath] = []\n      }\n      appPathRoutes[normalizedPath].push(entry)\n    })\n    return appPathRoutes\n  }\n\n  protected async run(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.run, async () =>\n      this.runImpl(req, res, parsedUrl)\n    )\n  }\n\n  private async runImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    await this.handleCatchallRenderRequest(req, res, parsedUrl)\n  }\n\n  private async pipe(\n    fn: (\n      ctx: RequestContext<ServerRequest, ServerResponse>\n    ) => Promise<ResponsePayload | null>,\n    partialContext: Omit<\n      RequestContext<ServerRequest, ServerResponse>,\n      'renderOpts'\n    >\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.pipe, async () =>\n      this.pipeImpl(fn, partialContext)\n    )\n  }\n\n  private async pipeImpl(\n    fn: (\n      ctx: RequestContext<ServerRequest, ServerResponse>\n    ) => Promise<ResponsePayload | null>,\n    partialContext: Omit<\n      RequestContext<ServerRequest, ServerResponse>,\n      'renderOpts'\n    >\n  ): Promise<void> {\n    const ua = partialContext.req.headers['user-agent'] || ''\n\n    const ctx: RequestContext<ServerRequest, ServerResponse> = {\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        // `renderOpts.botType` is accumulated in `this.renderImpl()`\n        supportsDynamicResponse: !this.renderOpts.botType,\n        serveStreamingMetadata: shouldServeStreamingMetadata(\n          ua,\n          this.nextConfig.htmlLimitedBots\n        ),\n      },\n    }\n\n    const payload = await fn(ctx)\n    if (payload === null) {\n      return\n    }\n    const { req, res } = ctx\n    const originalStatus = res.statusCode\n    const { body, type } = payload\n    let { cacheControl } = payload\n    if (!res.sent) {\n      const { generateEtags, poweredByHeader, dev } = this.renderOpts\n\n      // In dev, we should not cache pages for any reason.\n      if (dev) {\n        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n        cacheControl = undefined\n      }\n\n      if (cacheControl && cacheControl.expire === undefined) {\n        cacheControl.expire = this.nextConfig.expireTime\n      }\n\n      await this.sendRenderResult(req, res, {\n        result: body,\n        type,\n        generateEtags,\n        poweredByHeader,\n        cacheControl,\n      })\n      res.statusCode = originalStatus\n    }\n  }\n\n  private async getStaticHTML(\n    fn: (\n      ctx: RequestContext<ServerRequest, ServerResponse>\n    ) => Promise<ResponsePayload | null>,\n    partialContext: Omit<\n      RequestContext<ServerRequest, ServerResponse>,\n      'renderOpts'\n    >\n  ): Promise<string | null> {\n    const ctx: RequestContext<ServerRequest, ServerResponse> = {\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        supportsDynamicResponse: false,\n      },\n    }\n    const payload = await fn(ctx)\n    if (payload === null) {\n      return null\n    }\n    return payload.body.toUnchunkedString()\n  }\n\n  public async render(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    parsedUrl?: NextUrlWithParsedQuery,\n    internalRender = false\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.render, async () =>\n      this.renderImpl(req, res, pathname, query, parsedUrl, internalRender)\n    )\n  }\n\n  protected getWaitUntil(): WaitUntil | undefined {\n    const builtinRequestContext = getBuiltinRequestContext()\n    if (builtinRequestContext) {\n      // the platform provided a request context.\n      // use the `waitUntil` from there, whether actually present or not --\n      // if not present, `after` will error.\n\n      // NOTE: if we're in an edge runtime sandbox, this context will be used to forward the outer waitUntil.\n      return builtinRequestContext.waitUntil\n    }\n\n    if (this.minimalMode) {\n      // we're built for a serverless environment, and `waitUntil` is not available,\n      // but using a noop would likely lead to incorrect behavior,\n      // because we have no way of keeping the invocation alive.\n      // return nothing, and `after` will error if used.\n      //\n      // NOTE: for edge functions, `NextWebServer` always runs in minimal mode.\n      //\n      // NOTE: if we're in an edge runtime sandbox, waitUntil will be passed in using \"@next/request-context\",\n      // so we won't get here.\n      return undefined\n    }\n\n    return this.getInternalWaitUntil()\n  }\n\n  protected getInternalWaitUntil(): WaitUntil | undefined {\n    return undefined\n  }\n\n  private async renderImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    parsedUrl?: NextUrlWithParsedQuery,\n    internalRender = false\n  ): Promise<void> {\n    if (!pathname.startsWith('/')) {\n      console.warn(\n        `Cannot render page with path \"${pathname}\", did you mean \"/${pathname}\"?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`\n      )\n    }\n\n    if (\n      this.serverOptions.customServer &&\n      pathname === '/index' &&\n      !(await this.hasPage('/index'))\n    ) {\n      // maintain backwards compatibility for custom server\n      // (see custom-server integration tests)\n      pathname = '/'\n    }\n\n    const ua = req.headers['user-agent'] || ''\n    this.renderOpts.botType = getBotType(ua)\n\n    // we allow custom servers to call render for all URLs\n    // so check if we need to serve a static _next file or not.\n    // we don't modify the URL for _next/data request but still\n    // call render so we special case this to prevent an infinite loop\n    if (\n      !internalRender &&\n      !this.minimalMode &&\n      !getRequestMeta(req, 'isNextDataReq') &&\n      (req.url?.match(/^\\/_next\\//) ||\n        (this.hasStaticDir && req.url!.match(/^\\/static\\//)))\n    ) {\n      return this.handleRequest(req, res, parsedUrl)\n    }\n\n    if (isBlockedPage(pathname)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    return this.pipe((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  protected async getStaticPaths({\n    pathname,\n  }: {\n    pathname: string\n    requestHeaders: import('./lib/incremental-cache').IncrementalCache['requestHeaders']\n    page: string\n    isAppPath: boolean\n  }): Promise<{\n    staticPaths?: string[]\n    fallbackMode?: FallbackMode\n  }> {\n    // Read whether or not fallback should exist from the manifest.\n    const fallbackField =\n      this.getPrerenderManifest().dynamicRoutes[pathname]?.fallback\n\n    return {\n      // `staticPaths` is intentionally set to `undefined` as it should've\n      // been caught when checking disk data.\n      staticPaths: undefined,\n      fallbackMode: parseFallbackField(fallbackField),\n    }\n  }\n\n  private async renderToResponseWithComponents(\n    requestContext: RequestContext<ServerRequest, ServerResponse>,\n    findComponentsResult: FindComponentsResult\n  ): Promise<ResponsePayload | null> {\n    return getTracer().trace(\n      BaseServerSpan.renderToResponseWithComponents,\n      async () =>\n        this.renderToResponseWithComponentsImpl(\n          requestContext,\n          findComponentsResult\n        )\n    )\n  }\n\n  protected pathCouldBeIntercepted(resolvedPathname: string): boolean {\n    return (\n      isInterceptionRouteAppPath(resolvedPathname) ||\n      this.interceptionRoutePatterns.some((regexp) => {\n        return regexp.test(resolvedPathname)\n      })\n    )\n  }\n\n  protected setVaryHeader(\n    req: ServerRequest,\n    res: ServerResponse,\n    isAppPath: boolean,\n    resolvedPathname: string\n  ): void {\n    const baseVaryHeader = `${RSC_HEADER}, ${NEXT_ROUTER_STATE_TREE_HEADER}, ${NEXT_ROUTER_PREFETCH_HEADER}, ${NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`\n    const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false\n\n    let addedNextUrlToVary = false\n\n    if (isAppPath && this.pathCouldBeIntercepted(resolvedPathname)) {\n      // Interception route responses can vary based on the `Next-URL` header.\n      // We use the Vary header to signal this behavior to the client to properly cache the response.\n      res.appendHeader('vary', `${baseVaryHeader}, ${NEXT_URL}`)\n      addedNextUrlToVary = true\n    } else if (isAppPath || isRSCRequest) {\n      // We don't need to include `Next-URL` in the Vary header for non-interception routes since it won't affect the response.\n      // We also set this header for pages to avoid caching issues when navigating between pages and app.\n      res.appendHeader('vary', baseVaryHeader)\n    }\n\n    if (!addedNextUrlToVary) {\n      // Remove `Next-URL` from the request headers we determined it wasn't necessary to include in the Vary header.\n      // This is to avoid any dependency on the `Next-URL` header being present when preparing the response.\n      delete req.headers[NEXT_URL]\n    }\n  }\n\n  private async renderToResponseWithComponentsImpl(\n    {\n      req,\n      res,\n      pathname,\n      renderOpts: opts,\n    }: RequestContext<ServerRequest, ServerResponse>,\n    { components, query }: FindComponentsResult\n  ): Promise<ResponsePayload | null> {\n    if (pathname === UNDERSCORE_NOT_FOUND_ROUTE) {\n      pathname = '/404'\n    }\n    const isErrorPathname = pathname === '/_error'\n    const is404Page =\n      pathname === '/404' || (isErrorPathname && res.statusCode === 404)\n    const is500Page =\n      pathname === '/500' || (isErrorPathname && res.statusCode === 500)\n    const isAppPath = components.isAppPath === true\n\n    const hasServerProps = !!components.getServerSideProps\n    let hasGetStaticPaths = !!components.getStaticPaths\n    const isPossibleServerAction = getIsPossibleServerAction(req)\n    const hasGetInitialProps = !!components.Component?.getInitialProps\n    let isSSG = !!components.getStaticProps\n\n    // Not all CDNs respect the Vary header when caching. We must assume that\n    // only the URL is used to vary the responses. The Next client computes a\n    // hash of the header values and sends it as a search param. Before\n    // responding to a request, we must verify that the hash matches the\n    // expected value. Neglecting to do this properly can lead to cache\n    // poisoning attacks on certain CDNs.\n    // TODO: This is verification only runs during per-segment prefetch\n    // requests, since those are the only ones that both vary on a custom\n    // header and are cacheable. But for safety, we should run this\n    // verification for all requests, once we confirm the behavior is correct.\n    // Will need to update our test suite, since there are a handlful of unit\n    // tests that send fetch requests with custom headers but without a\n    // corresponding cache-busting search param.\n    // TODO: Consider not using custom request headers at all, and instead fully\n    // encode everything into the search param.\n    if (\n      this.isAppSegmentPrefetchEnabled &&\n      getRequestMeta(req, 'segmentPrefetchRSCRequest')\n    ) {\n      const headers = req.headers\n      const expectedHash = computeCacheBustingSearchParam(\n        headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()],\n        headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()],\n        headers[NEXT_ROUTER_STATE_TREE_HEADER.toLowerCase()],\n        headers[NEXT_URL.toLowerCase()]\n      )\n      const actualHash = getRequestMeta(req, 'cacheBustingSearchParam') ?? null\n      if (expectedHash !== actualHash) {\n        // The hash sent by the client does not match the expected value.\n        // Respond with an error.\n        res.statusCode = 400\n        res.body('Bad Request').send()\n        return null\n      }\n    }\n\n    // Compute the iSSG cache key. We use the rewroteUrl since\n    // pages with fallback: false are allowed to be rewritten to\n    // and we need to look up the path by the rewritten path\n    let urlPathname = parseUrl(req.url || '').pathname || '/'\n\n    let resolvedUrlPathname = getRequestMeta(req, 'rewroteURL') || urlPathname\n\n    this.setVaryHeader(req, res, isAppPath, resolvedUrlPathname)\n\n    let staticPaths: string[] | undefined\n    let fallbackMode: FallbackMode | undefined\n    let hasFallback = false\n\n    const isDynamic = isDynamicRoute(components.page)\n\n    const prerenderManifest = this.getPrerenderManifest()\n\n    if (isAppPath && isDynamic) {\n      const pathsResult = await this.getStaticPaths({\n        pathname,\n        page: components.page,\n        isAppPath,\n        requestHeaders: req.headers,\n      })\n\n      staticPaths = pathsResult.staticPaths\n      fallbackMode = pathsResult.fallbackMode\n      hasFallback = typeof fallbackMode !== 'undefined'\n\n      if (this.nextConfig.output === 'export') {\n        const page = components.page\n        if (!staticPaths) {\n          throw new Error(\n            `Page \"${page}\" is missing exported function \"generateStaticParams()\", which is required with \"output: export\" config.`\n          )\n        }\n\n        const resolvedWithoutSlash = removeTrailingSlash(resolvedUrlPathname)\n        if (!staticPaths.includes(resolvedWithoutSlash)) {\n          throw new Error(\n            `Page \"${page}\" is missing param \"${resolvedWithoutSlash}\" in \"generateStaticParams()\", which is required with \"output: export\" config.`\n          )\n        }\n      }\n\n      if (hasFallback) {\n        hasGetStaticPaths = true\n      }\n    }\n\n    if (\n      hasFallback ||\n      staticPaths?.includes(resolvedUrlPathname) ||\n      // this signals revalidation in deploy environments\n      // TODO: make this more generic\n      req.headers['x-now-route-matches']\n    ) {\n      isSSG = true\n    } else if (!this.renderOpts.dev) {\n      isSSG ||= !!prerenderManifest.routes[toRoute(pathname)]\n    }\n\n    // Toggle whether or not this is a Data request\n    const isNextDataRequest =\n      !!(\n        getRequestMeta(req, 'isNextDataReq') ||\n        (req.headers['x-nextjs-data'] &&\n          (this.serverOptions as any).webServerConfig)\n      ) &&\n      (isSSG || hasServerProps)\n\n    /**\n     * If true, this indicates that the request being made is for an app\n     * prefetch request.\n     */\n    const isPrefetchRSCRequest =\n      getRequestMeta(req, 'isPrefetchRSCRequest') ?? false\n\n    // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n\n    const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false\n\n    // when we are handling a middleware prefetch and it doesn't\n    // resolve to a static data route we bail early to avoid\n    // unexpected SSR invocations\n    if (\n      !isSSG &&\n      req.headers['x-middleware-prefetch'] &&\n      !(is404Page || pathname === '/_error')\n    ) {\n      res.setHeader(MATCHED_PATH_HEADER, pathname)\n      res.setHeader('x-middleware-skip', '1')\n      res.setHeader(\n        'cache-control',\n        'private, no-cache, no-store, max-age=0, must-revalidate'\n      )\n      res.body('{}').send()\n      return null\n    }\n\n    // normalize req.url for SSG paths as it is not exposed\n    // to getStaticProps and the asPath should not expose /_next/data\n    if (\n      isSSG &&\n      this.minimalMode &&\n      req.headers[MATCHED_PATH_HEADER] &&\n      req.url.startsWith('/_next/data')\n    ) {\n      req.url = this.stripNextDataPath(req.url)\n    }\n\n    const locale = getRequestMeta(req, 'locale')\n    const defaultLocale = isSSG\n      ? this.nextConfig.i18n?.defaultLocale\n      : getRequestMeta(req, 'defaultLocale')\n\n    if (\n      !!req.headers['x-nextjs-data'] &&\n      (!res.statusCode || res.statusCode === 200)\n    ) {\n      res.setHeader(\n        'x-nextjs-matched-path',\n        `${locale ? `/${locale}` : ''}${pathname}`\n      )\n    }\n\n    let routeModule: RouteModule | undefined\n    if (components.routeModule) {\n      routeModule = components.routeModule\n    }\n\n    /**\n     * If the route being rendered is an app page, and the ppr feature has been\n     * enabled, then the given route _could_ support PPR.\n     */\n    const couldSupportPPR: boolean =\n      this.isAppPPREnabled &&\n      typeof routeModule !== 'undefined' &&\n      isAppPageRouteModule(routeModule)\n\n    // When enabled, this will allow the use of the `?__nextppronly` query to\n    // enable debugging of the static shell.\n    const hasDebugStaticShellQuery =\n      process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' &&\n      typeof query.__nextppronly !== 'undefined' &&\n      couldSupportPPR\n\n    // When enabled, this will allow the use of the `?__nextppronly` query\n    // to enable debugging of the fallback shell.\n    const hasDebugFallbackShellQuery =\n      hasDebugStaticShellQuery && query.__nextppronly === 'fallback'\n\n    // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n    // prerender manifest and this is an app page.\n    const isRoutePPREnabled: boolean =\n      couldSupportPPR &&\n      ((\n        prerenderManifest.routes[pathname] ??\n        prerenderManifest.dynamicRoutes[pathname]\n      )?.renderingMode === 'PARTIALLY_STATIC' ||\n        // Ideally we'd want to check the appConfig to see if this page has PPR\n        // enabled or not, but that would require plumbing the appConfig through\n        // to the server during development. We assume that the page supports it\n        // but only during development.\n        (hasDebugStaticShellQuery &&\n          (this.renderOpts.dev === true ||\n            this.experimentalTestProxy === true)))\n\n    const isDebugStaticShell: boolean =\n      hasDebugStaticShellQuery && isRoutePPREnabled\n\n    // We should enable debugging dynamic accesses when the static shell\n    // debugging has been enabled and we're also in development mode.\n    const isDebugDynamicAccesses =\n      isDebugStaticShell && this.renderOpts.dev === true\n\n    const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled\n\n    // If we're in minimal mode, then try to get the postponed information from\n    // the request metadata. If available, use it for resuming the postponed\n    // render.\n    const minimalPostponed = isRoutePPREnabled\n      ? getRequestMeta(req, 'postponed')\n      : undefined\n\n    // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n    // we can use this fact to only generate the flight data for the request\n    // because we can't cache the HTML (as it's also dynamic).\n    const isDynamicRSCRequest =\n      isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest\n\n    // Need to read this before it's stripped by stripFlightHeaders. We don't\n    // need to transfer it to the request meta because it's only read\n    // within this function; the static segment data should have already been\n    // generated, so we will always either return a static response or a 404.\n    const segmentPrefetchHeader = getRequestMeta(\n      req,\n      'segmentPrefetchRSCRequest'\n    )\n\n    const isHtmlBot = isHtmlBotRequest(req)\n    if (isHtmlBot && isRoutePPREnabled) {\n      isSSG = false\n      this.renderOpts.serveStreamingMetadata = false\n    }\n\n    // we need to ensure the status code if /404 is visited directly\n    if (is404Page && !isNextDataRequest && !isRSCRequest) {\n      res.statusCode = 404\n    }\n\n    // ensure correct status is set when visiting a status page\n    // directly e.g. /500\n    if (STATIC_STATUS_PAGES.includes(pathname)) {\n      res.statusCode = parseInt(pathname.slice(1), 10)\n    }\n\n    if (\n      // Server actions can use non-GET/HEAD methods.\n      !isPossibleServerAction &&\n      // Resume can use non-GET/HEAD methods.\n      !minimalPostponed &&\n      !is404Page &&\n      !is500Page &&\n      pathname !== '/_error' &&\n      req.method !== 'HEAD' &&\n      req.method !== 'GET' &&\n      (typeof components.Component === 'string' || isSSG)\n    ) {\n      res.statusCode = 405\n      res.setHeader('Allow', ['GET', 'HEAD'])\n      res.body('Method Not Allowed').send()\n      return null\n    }\n\n    // handle static page\n    if (typeof components.Component === 'string') {\n      return {\n        type: 'html',\n        // TODO: Static pages should be serialized as RenderResult\n        body: RenderResult.fromStatic(components.Component),\n      }\n    }\n\n    // Ensure that if the `amp` query parameter is falsy that we remove it from\n    // the query object. This ensures it won't be found by the `in` operator.\n    if ('amp' in query && !query.amp) delete query.amp\n\n    if (opts.supportsDynamicResponse === true) {\n      const ua = req.headers['user-agent'] || ''\n      const isBotRequest = isBot(ua)\n      const isSupportedDocument =\n        typeof components.Document?.getInitialProps !== 'function' ||\n        // The built-in `Document` component also supports dynamic HTML for concurrent mode.\n        NEXT_BUILTIN_DOCUMENT in components.Document\n\n      // Disable dynamic HTML in cases that we know it won't be generated,\n      // so that we can continue generating a cache key when possible.\n      // TODO-APP: should the first render for a dynamic app path\n      // be static so we can collect revalidate and populate the\n      // cache if there are no dynamic data requirements\n      opts.supportsDynamicResponse =\n        !isSSG && !isBotRequest && !query.amp && isSupportedDocument\n    }\n\n    // In development, we always want to generate dynamic HTML.\n    if (!isNextDataRequest && isAppPath && opts.dev) {\n      opts.supportsDynamicResponse = true\n    }\n\n    const locales = this.nextConfig.i18n?.locales\n\n    let previewData: PreviewData\n    let isPreviewMode = false\n\n    if (hasServerProps || isSSG || isAppPath) {\n      // For the edge runtime, we don't support preview mode in SSG.\n      if (process.env.NEXT_RUNTIME !== 'edge') {\n        const { tryGetPreviewData } =\n          require('./api-utils/node/try-get-preview-data') as typeof import('./api-utils/node/try-get-preview-data')\n        previewData = tryGetPreviewData(\n          req,\n          res,\n          this.renderOpts.previewProps,\n          !!this.nextConfig.experimental.multiZoneDraftMode\n        )\n        isPreviewMode = previewData !== false\n      }\n    }\n\n    // If this is a request for an app path that should be statically generated\n    // and we aren't in the edge runtime, strip the flight headers so it will\n    // generate the static response.\n    if (\n      isAppPath &&\n      !opts.dev &&\n      !isPreviewMode &&\n      isSSG &&\n      isRSCRequest &&\n      !isDynamicRSCRequest &&\n      (!isEdgeRuntime(opts.runtime) ||\n        (this.serverOptions as any).webServerConfig)\n    ) {\n      stripFlightHeaders(req.headers)\n    }\n\n    let { isOnDemandRevalidate, revalidateOnlyGenerated } =\n      checkIsOnDemandRevalidate(req, this.renderOpts.previewProps)\n\n    if (isSSG && this.minimalMode && req.headers[MATCHED_PATH_HEADER]) {\n      // the url value is already correct when the matched-path header is set\n      resolvedUrlPathname = urlPathname\n    }\n\n    urlPathname = removeTrailingSlash(urlPathname)\n    resolvedUrlPathname = removeTrailingSlash(resolvedUrlPathname)\n    if (this.localeNormalizer) {\n      resolvedUrlPathname = this.localeNormalizer.normalize(resolvedUrlPathname)\n    }\n\n    const handleRedirect = (pageData: any) => {\n      const redirect = {\n        destination: pageData.pageProps.__N_REDIRECT,\n        statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n        basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH,\n      }\n      const statusCode = getRedirectStatus(redirect)\n      const { basePath } = this.nextConfig\n\n      if (\n        basePath &&\n        redirect.basePath !== false &&\n        redirect.destination.startsWith('/')\n      ) {\n        redirect.destination = `${basePath}${redirect.destination}`\n      }\n\n      if (redirect.destination.startsWith('/')) {\n        redirect.destination = normalizeRepeatedSlashes(redirect.destination)\n      }\n\n      res\n        .redirect(redirect.destination, statusCode)\n        .body(redirect.destination)\n        .send()\n    }\n\n    // remove /_next/data prefix from urlPathname so it matches\n    // for direct page visit and /_next/data visit\n    if (isNextDataRequest) {\n      resolvedUrlPathname = this.stripNextDataPath(resolvedUrlPathname)\n      urlPathname = this.stripNextDataPath(urlPathname)\n    }\n\n    let ssgCacheKey: string | null = null\n    if (\n      !isPreviewMode &&\n      isSSG &&\n      !opts.supportsDynamicResponse &&\n      !isPossibleServerAction &&\n      !minimalPostponed &&\n      !isDynamicRSCRequest\n    ) {\n      ssgCacheKey = `${locale ? `/${locale}` : ''}${\n        (pathname === '/' || resolvedUrlPathname === '/') && locale\n          ? ''\n          : resolvedUrlPathname\n      }${query.amp ? '.amp' : ''}`\n    }\n\n    if ((is404Page || is500Page) && isSSG) {\n      ssgCacheKey = `${locale ? `/${locale}` : ''}${pathname}${\n        query.amp ? '.amp' : ''\n      }`\n    }\n\n    if (ssgCacheKey) {\n      ssgCacheKey = decodePathParams(ssgCacheKey)\n\n      // ensure /index and / is normalized to one key\n      ssgCacheKey =\n        ssgCacheKey === '/index' && pathname === '/' ? '/' : ssgCacheKey\n    }\n    let protocol: 'http:' | 'https:' = 'https:'\n\n    try {\n      const parsedFullUrl = new URL(\n        getRequestMeta(req, 'initURL') || '/',\n        'http://n'\n      )\n      protocol = parsedFullUrl.protocol as 'https:' | 'http:'\n    } catch {}\n\n    // use existing incrementalCache instance if available\n    const incrementalCache: import('./lib/incremental-cache').IncrementalCache =\n      process.env.NEXT_RUNTIME === 'edge' &&\n      (globalThis as any).__incrementalCache\n        ? (globalThis as any).__incrementalCache\n        : await this.getIncrementalCache({\n            requestHeaders: Object.assign({}, req.headers),\n            requestProtocol: protocol.substring(0, protocol.length - 1) as\n              | 'http'\n              | 'https',\n          })\n\n    // TODO: investigate, this is not safe across multiple concurrent requests\n    incrementalCache.resetRequestCache()\n\n    type RendererContext = {\n      /**\n       * The postponed data for this render. This is only provided when resuming\n       * a render that has been postponed.\n       */\n      postponed: string | undefined\n\n      pagesFallback: boolean | undefined\n\n      /**\n       * The unknown route params for this render.\n       */\n      fallbackRouteParams: FallbackRouteParams | null\n    }\n    type Renderer = (\n      context: RendererContext\n    ) => Promise<ResponseCacheEntry | null>\n\n    const doRender: Renderer = async ({\n      postponed,\n      pagesFallback = false,\n      fallbackRouteParams,\n    }) => {\n      // In development, we always want to generate dynamic HTML.\n      let supportsDynamicResponse: boolean =\n        // If we're in development, we always support dynamic HTML, unless it's\n        // a data request, in which case we only produce static HTML.\n        (!isNextDataRequest && opts.dev === true) ||\n        // If this is not SSG or does not have static paths, then it supports\n        // dynamic HTML.\n        (!isSSG && !hasGetStaticPaths) ||\n        // If this request has provided postponed data, it supports dynamic\n        // HTML.\n        typeof postponed === 'string' ||\n        // If this is a dynamic RSC request, then this render supports dynamic\n        // HTML (it's dynamic).\n        isDynamicRSCRequest\n\n      const origQuery = parseUrl(req.url || '', true).query\n\n      // clear any dynamic route params so they aren't in\n      // the resolvedUrl\n      if (opts.params) {\n        Object.keys(opts.params).forEach((key) => {\n          delete origQuery[key]\n        })\n      }\n      const hadTrailingSlash =\n        urlPathname !== '/' && this.nextConfig.trailingSlash\n\n      const resolvedUrl = formatUrl({\n        pathname: `${resolvedUrlPathname}${hadTrailingSlash ? '/' : ''}`,\n        // make sure to only add query values from original URL\n        query: origQuery,\n      })\n\n      // When html bots request PPR page, perform the full dynamic rendering.\n      const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n\n      const renderOpts: LoadedRenderOpts = {\n        ...components,\n        ...opts,\n        ...(isAppPath\n          ? {\n              incrementalCache,\n              // This is a revalidation request if the request is for a static\n              // page and it is not being resumed from a postponed render and\n              // it is not a dynamic RSC request then it is a revalidation\n              // request.\n              isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n              serverActions: this.nextConfig.experimental.serverActions,\n            }\n          : {}),\n        isNextDataRequest,\n        resolvedUrl,\n        locale,\n        locales,\n        defaultLocale,\n        multiZoneDraftMode: this.nextConfig.experimental.multiZoneDraftMode,\n        // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n        // and not the resolved URL to prevent a hydration mismatch on\n        // asPath\n        resolvedAsPath:\n          hasServerProps || hasGetInitialProps\n            ? formatUrl({\n                // we use the original URL pathname less the _next/data prefix if\n                // present\n                pathname: `${urlPathname}${hadTrailingSlash ? '/' : ''}`,\n                query: origQuery,\n              })\n            : resolvedUrl,\n        experimental: {\n          ...opts.experimental,\n          isRoutePPREnabled,\n        },\n        supportsDynamicResponse,\n        shouldWaitOnAllReady,\n        isOnDemandRevalidate,\n        isDraftMode: isPreviewMode,\n        isPossibleServerAction,\n        postponed,\n        waitUntil: this.getWaitUntil(),\n        onClose: res.onClose.bind(res),\n        onAfterTaskError: undefined,\n        // only available in dev\n        setIsrStatus: (this as any).setIsrStatus,\n      }\n\n      if (isDebugStaticShell || isDebugDynamicAccesses) {\n        supportsDynamicResponse = false\n        renderOpts.nextExport = true\n        renderOpts.supportsDynamicResponse = false\n        renderOpts.isStaticGeneration = true\n        renderOpts.isRevalidate = true\n        renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses\n      }\n\n      // Legacy render methods will return a render result that needs to be\n      // served by the server.\n      let result: RenderResult\n\n      if (routeModule) {\n        if (isAppRouteRouteModule(routeModule)) {\n          if (\n            // The type check here ensures that `req` is correctly typed, and the\n            // environment variable check provides dead code elimination.\n            process.env.NEXT_RUNTIME === 'edge' ||\n            !isNodeNextRequest(req) ||\n            !isNodeNextResponse(res)\n          ) {\n            throw new Error(\n              'Invariant: App Route Route Modules cannot be used in the edge runtime'\n            )\n          }\n\n          const context: AppRouteRouteHandlerContext = {\n            params: opts.params,\n            prerenderManifest,\n            renderOpts: {\n              experimental: {\n                dynamicIO: renderOpts.experimental.dynamicIO,\n                authInterrupts: renderOpts.experimental.authInterrupts,\n              },\n              supportsDynamicResponse,\n              incrementalCache,\n              cacheLifeProfiles: this.nextConfig.experimental?.cacheLife,\n              isRevalidate: isSSG,\n              waitUntil: this.getWaitUntil(),\n              onClose: res.onClose.bind(res),\n              onAfterTaskError: undefined,\n              onInstrumentationRequestError:\n                this.renderOpts.onInstrumentationRequestError,\n            },\n            sharedContext: {\n              buildId: this.buildId,\n            },\n          }\n\n          try {\n            const request = NextRequestAdapter.fromNodeNextRequest(\n              req,\n              signalFromNodeResponse(res.originalResponse)\n            )\n\n            const response = await routeModule.handle(request, context)\n\n            ;(req as any).fetchMetrics = (\n              context.renderOpts as any\n            ).fetchMetrics\n\n            const cacheTags = context.renderOpts.collectedTags\n\n            // If the request is for a static response, we can cache it so long\n            // as it's not edge.\n            if (isSSG) {\n              const blob = await response.blob()\n\n              // Copy the headers from the response.\n              const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n              if (cacheTags) {\n                headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n              }\n\n              if (!headers['content-type'] && blob.type) {\n                headers['content-type'] = blob.type\n              }\n\n              const revalidate =\n                typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n                context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                  ? false\n                  : context.renderOpts.collectedRevalidate\n\n              const expire =\n                typeof context.renderOpts.collectedExpire === 'undefined' ||\n                context.renderOpts.collectedExpire >= INFINITE_CACHE\n                  ? undefined\n                  : context.renderOpts.collectedExpire\n\n              // Create the cache entry for the response.\n              const cacheEntry: ResponseCacheEntry = {\n                value: {\n                  kind: CachedRouteKind.APP_ROUTE,\n                  status: response.status,\n                  body: Buffer.from(await blob.arrayBuffer()),\n                  headers,\n                },\n                cacheControl: { revalidate, expire },\n              }\n\n              return cacheEntry\n            }\n            let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n            // Attempt using provided waitUntil if available\n            // if it's not we fallback to sendResponse's handling\n            if (pendingWaitUntil) {\n              if (context.renderOpts.waitUntil) {\n                context.renderOpts.waitUntil(pendingWaitUntil)\n                pendingWaitUntil = undefined\n              }\n            }\n\n            // Send the response now that we have copied it into the cache.\n            await sendResponse(\n              req,\n              res,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          } catch (err) {\n            await this.instrumentationOnRequestError(err, req, {\n              routerKind: 'App Router',\n              routePath: pathname,\n              routeType: 'route',\n              revalidateReason: getRevalidateReason(renderOpts),\n            })\n\n            // If this is during static generation, throw the error again.\n            if (isSSG) throw err\n\n            Log.error(err)\n\n            // Otherwise, send a 500 response.\n            await sendResponse(req, res, new Response(null, { status: 500 }))\n\n            return null\n          }\n        } else if (\n          isPagesRouteModule(routeModule) ||\n          isAppPageRouteModule(routeModule)\n        ) {\n          // An OPTIONS request to a page handler is invalid.\n          if (req.method === 'OPTIONS' && !is404Page) {\n            await sendResponse(req, res, new Response(null, { status: 400 }))\n            return null\n          }\n\n          if (isPagesRouteModule(routeModule)) {\n            const request = isNodeNextRequest(req) ? req.originalRequest : req\n\n            const response = isNodeNextResponse(res)\n              ? res.originalResponse\n              : res\n\n            if (\n              components.ComponentMod.handler &&\n              process.env.NEXT_RUNTIME !== 'edge'\n            ) {\n              const parsedInitUrl = parseUrl(\n                getRequestMeta(req, 'initURL') || req.url\n              )\n              request.url =\n                req.url = `${parsedInitUrl.pathname}${parsedInitUrl.search || ''}`\n\n              // propagate the request context for dev\n              setRequestMeta(request, getRequestMeta(req))\n              addRequestMeta(request, 'projectDir', this.dir)\n              addRequestMeta(request, 'isIsrFallback', pagesFallback)\n              addRequestMeta(request, 'query', query)\n              addRequestMeta(request, 'params', opts.params)\n              addRequestMeta(\n                request,\n                'ampValidator',\n                this.renderOpts.ampValidator\n              )\n\n              if (renderOpts.err) {\n                addRequestMeta(request, 'invokeError', renderOpts.err)\n              }\n              const handler: (\n                req: ServerRequest | IncomingMessage,\n                res: ServerResponse | HTTPServerResponse,\n                ctx: {\n                  waitUntil: ReturnType<Server['getWaitUntil']>\n                }\n              ) => Promise<RenderResult> = components.ComponentMod.handler\n\n              result = await handler(request, response, {\n                waitUntil: this.getWaitUntil(),\n              })\n\n              if (!result) {\n                throw new Error(\n                  `Invariant: missing result from invoking ${pathname} handler`\n                )\n              }\n            } else {\n              // Due to the way we pass data by mutating `renderOpts`, we can't extend\n              // the object here but only updating its `clientReferenceManifest` and\n              // `nextFontManifest` properties.\n              // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n              renderOpts.nextFontManifest = this.nextFontManifest\n              renderOpts.clientReferenceManifest =\n                components.clientReferenceManifest\n\n              // Call the built-in render method on the module.\n              try {\n                result = await routeModule.render(\n                  request as any,\n                  response as any,\n                  {\n                    page: pathname,\n                    params: opts.params,\n                    query,\n                    renderOpts,\n                    sharedContext: {\n                      buildId: this.buildId,\n                      deploymentId: this.nextConfig.deploymentId,\n                      customServer:\n                        this.serverOptions.customServer || undefined,\n                    },\n                    renderContext: {\n                      isFallback: pagesFallback,\n                      isDraftMode: renderOpts.isDraftMode,\n                      developmentNotFoundSourcePage: getRequestMeta(\n                        req,\n                        'developmentNotFoundSourcePage'\n                      ),\n                    },\n                  }\n                )\n              } catch (err) {\n                await this.instrumentationOnRequestError(err, req, {\n                  routerKind: 'Pages Router',\n                  routePath: pathname,\n                  routeType: 'render',\n                  revalidateReason: getRevalidateReason({\n                    isRevalidate: isSSG,\n                    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n                  }),\n                })\n                throw err\n              }\n            }\n          } else {\n            const module = components.routeModule as AppPageRouteModule\n\n            // Due to the way we pass data by mutating `renderOpts`, we can't extend the\n            // object here but only updating its `nextFontManifest` field.\n            // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n            renderOpts.nextFontManifest = this.nextFontManifest\n\n            const context: AppPageRouteHandlerContext = {\n              page: is404Page ? '/404' : pathname,\n              params: opts.params,\n              query,\n              fallbackRouteParams,\n              renderOpts,\n              serverComponentsHmrCache: this.getServerComponentsHmrCache(),\n              sharedContext: {\n                buildId: this.buildId,\n              },\n            }\n\n            // TODO: adapt for putting the RDC inside the postponed data\n            // If we're in dev, and this isn't a prefetch or a server action,\n            // we should seed the resume data cache.\n            if (\n              this.nextConfig.experimental.dynamicIO &&\n              this.renderOpts.dev &&\n              !isPrefetchRSCRequest &&\n              !isPossibleServerAction\n            ) {\n              const warmup = await module.warmup(req, res, context)\n\n              // If the warmup is successful, we should use the resume data\n              // cache from the warmup.\n              if (warmup.metadata.devRenderResumeDataCache) {\n                renderOpts.devRenderResumeDataCache =\n                  warmup.metadata.devRenderResumeDataCache\n              }\n            }\n\n            // Call the built-in render method on the module.\n            result = await module.render(req, res, context)\n          }\n        } else {\n          throw new Error('Invariant: Unknown route module type')\n        }\n      } else {\n        // If we didn't match a page, we should fallback to using the legacy\n        // render method.\n        result = await this.renderHTML(req, res, pathname, query, renderOpts)\n      }\n\n      const { metadata } = result\n\n      const {\n        cacheControl,\n        headers = {},\n        // Add any fetch tags that were on the page to the response headers.\n        fetchTags: cacheTags,\n      } = metadata\n\n      if (cacheTags) {\n        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n      }\n\n      // Pull any fetch metrics from the render onto the request.\n      ;(req as any).fetchMetrics = metadata.fetchMetrics\n\n      // we don't throw static to dynamic errors in dev as isSSG\n      // is a best guess in dev since we don't have the prerender pass\n      // to know whether the path is actually static or not\n      if (\n        isAppPath &&\n        isSSG &&\n        cacheControl?.revalidate === 0 &&\n        !this.renderOpts.dev &&\n        !isRoutePPREnabled\n      ) {\n        const staticBailoutInfo = metadata.staticBailoutInfo\n\n        const err = new Error(\n          `Page changed from static to dynamic at runtime ${urlPathname}${\n            staticBailoutInfo?.description\n              ? `, reason: ${staticBailoutInfo.description}`\n              : ``\n          }` +\n            `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`\n        )\n\n        if (staticBailoutInfo?.stack) {\n          const stack = staticBailoutInfo.stack\n          err.stack = err.message + stack.substring(stack.indexOf('\\n'))\n        }\n\n        throw err\n      }\n\n      // Based on the metadata, we can determine what kind of cache result we\n      // should return.\n\n      // Handle `isNotFound`.\n      if ('isNotFound' in metadata && metadata.isNotFound) {\n        return {\n          value: null,\n          cacheControl,\n        } satisfies ResponseCacheEntry\n      }\n\n      // Handle `isRedirect`.\n      if (metadata.isRedirect) {\n        return {\n          value: {\n            kind: CachedRouteKind.REDIRECT,\n            props: metadata.pageData ?? metadata.flightData,\n          } satisfies CachedRedirectValue,\n          cacheControl,\n        } satisfies ResponseCacheEntry\n      }\n\n      // Handle `isNull`.\n      if (result.isNull) {\n        return null\n      }\n\n      // We now have a valid HTML result that we can return to the user.\n      if (isAppPath) {\n        return {\n          value: {\n            kind: CachedRouteKind.APP_PAGE,\n            html: result,\n            headers,\n            rscData: metadata.flightData,\n            postponed: metadata.postponed,\n            status: metadata.statusCode,\n            segmentData: metadata.segmentData,\n          } satisfies CachedAppPageValue,\n          cacheControl,\n        } satisfies ResponseCacheEntry\n      }\n\n      return {\n        value: {\n          kind: CachedRouteKind.PAGES,\n          html: result,\n          pageData: metadata.pageData ?? metadata.flightData,\n          headers,\n          status: isAppPath ? res.statusCode : undefined,\n        } satisfies CachedPageValue,\n        cacheControl,\n      }\n    }\n\n    let responseGenerator: ResponseGenerator = async ({\n      hasResolved,\n      previousCacheEntry,\n      isRevalidating,\n    }): Promise<ResponseCacheEntry | null> => {\n      const isProduction = !this.renderOpts.dev\n      const didRespond = hasResolved || res.sent\n\n      // If we haven't found the static paths for the route, then do it now.\n      if (!staticPaths && isDynamic) {\n        if (hasGetStaticPaths) {\n          const pathsResult = await this.getStaticPaths({\n            pathname,\n            requestHeaders: req.headers,\n            isAppPath,\n            page: components.page,\n          })\n\n          staticPaths = pathsResult.staticPaths\n          fallbackMode = pathsResult.fallbackMode\n        } else {\n          staticPaths = undefined\n          fallbackMode = FallbackMode.NOT_FOUND\n        }\n      }\n\n      // When serving a bot request, we want to serve a blocking render and not\n      // the prerendered page. This ensures that the correct content is served\n      // to the bot in the head.\n      if (\n        fallbackMode === FallbackMode.PRERENDER &&\n        isBot(req.headers['user-agent'] || '')\n      ) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      // skip on-demand revalidate if cache is not present and\n      // revalidate-if-generated is set\n      if (\n        isOnDemandRevalidate &&\n        revalidateOnlyGenerated &&\n        !previousCacheEntry &&\n        !this.minimalMode\n      ) {\n        await this.render404(req, res)\n        return null\n      }\n\n      if (previousCacheEntry?.isStale === -1) {\n        isOnDemandRevalidate = true\n      }\n\n      // TODO: adapt for PPR\n      // only allow on-demand revalidate for fallback: true/blocking\n      // or for prerendered fallback: false paths\n      if (\n        isOnDemandRevalidate &&\n        (fallbackMode !== FallbackMode.NOT_FOUND || previousCacheEntry)\n      ) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      // We use `ssgCacheKey` here as it is normalized to match the encoding\n      // from getStaticPaths along with including the locale.\n      //\n      // We use the `resolvedUrlPathname` for the development case when this\n      // is an app path since it doesn't include locale information.\n      //\n      // We decode the `resolvedUrlPathname` to correctly match the app path\n      // with prerendered paths.\n      let staticPathKey = ssgCacheKey\n      if (!staticPathKey && opts.dev && isAppPath) {\n        staticPathKey = decodePathParams(resolvedUrlPathname)\n      }\n      if (staticPathKey && query.amp) {\n        staticPathKey = staticPathKey.replace(/\\.amp$/, '')\n      }\n\n      const isPageIncludedInStaticPaths =\n        staticPathKey && staticPaths?.includes(staticPathKey)\n\n      // When experimental compile is used, no pages have been prerendered,\n      // so they should all be blocking.\n\n      if (this.nextConfig.experimental.isExperimentalCompile) {\n        fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n      }\n\n      // When we did not respond from cache, we need to choose to block on\n      // rendering or return a skeleton.\n      //\n      // - Data requests always block.\n      // - Blocking mode fallback always blocks.\n      // - Preview mode toggles all pages to be resolved in a blocking manner.\n      // - Non-dynamic pages should block (though this is an impossible\n      //   case in production).\n      // - Dynamic pages should return their skeleton if not defined in\n      //   getStaticPaths, then finish the data request on the client-side.\n      //\n      if (\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        !this.minimalMode &&\n        fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER &&\n        staticPathKey &&\n        !didRespond &&\n        !isPreviewMode &&\n        isDynamic &&\n        (isProduction || !staticPaths || !isPageIncludedInStaticPaths)\n      ) {\n        if (\n          // In development, fall through to render to handle missing\n          // getStaticPaths.\n          (isProduction || (staticPaths && staticPaths?.length > 0)) &&\n          // When fallback isn't present, abort this render so we 404\n          fallbackMode === FallbackMode.NOT_FOUND\n        ) {\n          throw new NoFallbackError()\n        }\n\n        let fallbackResponse: ResponseCacheEntry | null | undefined\n\n        // If this is a pages router page.\n        if (isPagesRouteModule(components.routeModule) && !isNextDataRequest) {\n          // We use the response cache here to handle the revalidation and\n          // management of the fallback shell.\n          fallbackResponse = await this.responseCache.get(\n            isProduction ? (locale ? `/${locale}${pathname}` : pathname) : null,\n            // This is the response generator for the fallback shell.\n            async ({\n              previousCacheEntry: previousFallbackCacheEntry = null,\n            }) => {\n              // For the pages router, fallbacks cannot be revalidated or\n              // generated in production. In the case of a missing fallback,\n              // we return null, but if it's being revalidated, we just return\n              // the previous fallback cache entry. This preserves the previous\n              // behavior.\n              if (isProduction) {\n                return toResponseCacheEntry(previousFallbackCacheEntry)\n              }\n\n              // We pass `undefined` and `null` as it doesn't apply to the pages\n              // router.\n              return doRender({\n                postponed: undefined,\n                // For the pages router, fallbacks can only be generated on\n                // demand in development, so if we're not in production, and we\n                // aren't a app path.\n                pagesFallback: true,\n                fallbackRouteParams: null,\n              })\n            },\n            {\n              routeKind: RouteKind.PAGES,\n              incrementalCache,\n              isRoutePPREnabled,\n              isFallback: true,\n            }\n          )\n        }\n        // If this is a app router page, PPR is enabled, and PFPR is also\n        // enabled, then we should use the fallback renderer.\n        else if (\n          isRoutePPREnabled &&\n          isAppPageRouteModule(components.routeModule) &&\n          !isRSCRequest\n        ) {\n          // We use the response cache here to handle the revalidation and\n          // management of the fallback shell.\n          fallbackResponse = await this.responseCache.get(\n            isProduction ? pathname : null,\n            // This is the response generator for the fallback shell.\n            async () =>\n              doRender({\n                // We pass `undefined` as rendering a fallback isn't resumed\n                // here.\n                postponed: undefined,\n                pagesFallback: undefined,\n                fallbackRouteParams:\n                  // If we're in production of we're debugging the fallback\n                  // shell then we should postpone when dynamic params are\n                  // accessed.\n                  isProduction || isDebugFallbackShell\n                    ? getFallbackRouteParams(pathname)\n                    : null,\n              }),\n            {\n              routeKind: RouteKind.APP_PAGE,\n              incrementalCache,\n              isRoutePPREnabled,\n              isFallback: true,\n            }\n          )\n        }\n\n        // If the fallback response was set to null, then we should return null.\n        if (fallbackResponse === null) return null\n\n        // Otherwise, if we did get a fallback response, we should return it.\n        if (fallbackResponse) {\n          // Remove the cache control from the response to prevent it from being\n          // used in the surrounding cache.\n          delete fallbackResponse.cacheControl\n\n          return fallbackResponse\n        }\n      }\n\n      // Only requests that aren't revalidating can be resumed. If we have the\n      // minimal postponed data, then we should resume the render with it.\n      const postponed =\n        !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n          ? minimalPostponed\n          : undefined\n\n      // When we're in minimal mode, if we're trying to debug the static shell,\n      // we should just return nothing instead of resuming the dynamic render.\n      if (\n        (isDebugStaticShell || isDebugDynamicAccesses) &&\n        typeof postponed !== 'undefined'\n      ) {\n        return {\n          cacheControl: { revalidate: 1, expire: undefined },\n          value: {\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(''),\n            pageData: {},\n            headers: undefined,\n            status: undefined,\n          } satisfies CachedPageValue,\n        }\n      }\n\n      // If this is a dynamic route with PPR enabled and the default route\n      // matches were set, then we should pass the fallback route params to\n      // the renderer as this is a fallback revalidation request.\n      const fallbackRouteParams =\n        isDynamic &&\n        isRoutePPREnabled &&\n        (getRequestMeta(req, 'renderFallbackShell') || isDebugFallbackShell)\n          ? getFallbackRouteParams(pathname)\n          : null\n\n      // Perform the render.\n      return doRender({\n        postponed,\n        pagesFallback: undefined,\n        fallbackRouteParams,\n      })\n    }\n\n    const cacheEntry = await this.responseCache.get(\n      ssgCacheKey,\n      responseGenerator,\n      {\n        routeKind:\n          // If the route module is not defined, we can assume it's a page being\n          // rendered and thus check isAppPath.\n          routeModule?.definition.kind ??\n          (isAppPath ? RouteKind.APP_PAGE : RouteKind.PAGES),\n        incrementalCache,\n        isOnDemandRevalidate,\n        isPrefetch: req.headers.purpose === 'prefetch',\n        isRoutePPREnabled,\n      }\n    )\n\n    if (isPreviewMode) {\n      res.setHeader(\n        'Cache-Control',\n        'private, no-cache, no-store, max-age=0, must-revalidate'\n      )\n    }\n\n    if (!cacheEntry) {\n      if (ssgCacheKey && !(isOnDemandRevalidate && revalidateOnlyGenerated)) {\n        // A cache entry might not be generated if a response is written\n        // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n        // have a cache key. If we do have a cache key but we don't end up\n        // with a cache entry, then either Next.js or the application has a\n        // bug that needs fixing.\n        throw new Error('invariant: cache entry required but not generated')\n      }\n      return null\n    }\n\n    const didPostpone =\n      cacheEntry.value?.kind === CachedRouteKind.APP_PAGE &&\n      typeof cacheEntry.value.postponed === 'string'\n\n    if (\n      isSSG &&\n      // We don't want to send a cache header for requests that contain dynamic\n      // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n      // request, then we should set the cache header.\n      !isDynamicRSCRequest &&\n      (!didPostpone || isPrefetchRSCRequest)\n    ) {\n      if (!this.minimalMode) {\n        // set x-nextjs-cache header to match the header\n        // we set for the image-optimizer\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n      // Set a header used by the client router to signal the response is static\n      // and should respect the `static` cache staleTime value.\n      res.setHeader(NEXT_IS_PRERENDER_HEADER, '1')\n    }\n\n    const { value: cachedData } = cacheEntry\n\n    // If the cache value is an image, we should error early.\n    if (cachedData?.kind === CachedRouteKind.IMAGE) {\n      throw new InvariantError('SSG should not return an image cache value')\n    }\n\n    // Coerce the cache control parameter from the render.\n    let cacheControl: CacheControl | undefined\n\n    // If this is a resume request in minimal mode it is streamed with dynamic\n    // content and should not be cached.\n    if (minimalPostponed) {\n      cacheControl = { revalidate: 0, expire: undefined }\n    }\n\n    // If this is in minimal mode and this is a flight request that isn't a\n    // prefetch request while PPR is enabled, it cannot be cached as it contains\n    // dynamic content.\n    else if (\n      this.minimalMode &&\n      isRSCRequest &&\n      !isPrefetchRSCRequest &&\n      isRoutePPREnabled\n    ) {\n      cacheControl = { revalidate: 0, expire: undefined }\n    } else if (!this.renderOpts.dev || (hasServerProps && !isNextDataRequest)) {\n      // If this is a preview mode request, we shouldn't cache it\n      if (isPreviewMode) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      }\n\n      // If this isn't SSG, then we should set change the header only if it is\n      // not set already.\n      else if (!isSSG) {\n        if (!res.getHeader('Cache-Control')) {\n          cacheControl = { revalidate: 0, expire: undefined }\n        }\n      }\n\n      // If we are rendering the 404 page we derive the cache-control\n      // revalidate period from the value that trigged the not found\n      // to be rendered. So if `getStaticProps` returns\n      // { notFound: true, revalidate 60 } the revalidate period should\n      // be 60 but if a static asset 404s directly it should have a revalidate\n      // period of 0 so that it doesn't get cached unexpectedly by a CDN\n      else if (is404Page) {\n        const notFoundRevalidate = getRequestMeta(req, 'notFoundRevalidate')\n\n        cacheControl = {\n          revalidate:\n            typeof notFoundRevalidate === 'undefined' ? 0 : notFoundRevalidate,\n          expire: undefined,\n        }\n      } else if (is500Page) {\n        cacheControl = { revalidate: 0, expire: undefined }\n      } else if (cacheEntry.cacheControl) {\n        // If the cache entry has a cache control with a revalidate value that's\n        // a number, use it.\n        if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n          if (cacheEntry.cacheControl.revalidate < 1) {\n            throw new Error(\n              `Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`\n            )\n          }\n\n          cacheControl = {\n            revalidate: cacheEntry.cacheControl.revalidate,\n            expire:\n              cacheEntry.cacheControl?.expire ?? this.nextConfig.expireTime,\n          }\n        }\n        // Otherwise if the revalidate value is false, then we should use the\n        // cache time of one year.\n        else {\n          cacheControl = { revalidate: CACHE_ONE_YEAR, expire: undefined }\n        }\n      }\n    }\n\n    cacheEntry.cacheControl = cacheControl\n\n    if (\n      typeof segmentPrefetchHeader === 'string' &&\n      cachedData?.kind === CachedRouteKind.APP_PAGE &&\n      cachedData.segmentData\n    ) {\n      // This is a prefetch request issued by the client Segment Cache. These\n      // should never reach the application layer (lambda). We should either\n      // respond from the cache (HIT) or respond with 204 No Content (MISS).\n\n      // Set a header to indicate that PPR is enabled for this route. This\n      // lets the client distinguish between a regular cache miss and a cache\n      // miss due to PPR being disabled. In other contexts this header is used\n      // to indicate that the response contains dynamic data, but here we're\n      // only using it to indicate that the feature is enabled  the segment\n      // response itself contains whether the data is dynamic.\n      res.setHeader(NEXT_DID_POSTPONE_HEADER, '2')\n\n      // Add the cache tags header to the response if it exists and we're in\n      // minimal mode while rendering a static page.\n      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n      if (this.minimalMode && isSSG && tags && typeof tags === 'string') {\n        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n      }\n\n      const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader)\n      if (matchedSegment !== undefined) {\n        // Cache hit\n        return {\n          type: 'rsc',\n          body: RenderResult.fromStatic(matchedSegment),\n          // TODO: Eventually this should use cache control of the individual\n          // segment, not the whole page.\n          cacheControl: cacheEntry.cacheControl,\n        }\n      }\n\n      // Cache miss. Either a cache entry for this route has not been generated\n      // (which technically should not be possible when PPR is enabled, because\n      // at a minimum there should always be a fallback entry) or there's no\n      // match for the requested segment. Respond with a 204 No Content. We\n      // don't bother to respond with 404, because these requests are only\n      // issued as part of a prefetch.\n      res.statusCode = 204\n      return {\n        type: 'rsc',\n        body: RenderResult.fromStatic(''),\n        cacheControl: cacheEntry?.cacheControl,\n      }\n    }\n\n    // If there's a callback for `onCacheEntry`, call it with the cache entry\n    // and the revalidate options.\n    const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n    if (onCacheEntry) {\n      const finished = await onCacheEntry(\n        {\n          ...cacheEntry,\n          // TODO: remove this when upstream doesn't\n          // always expect this value to be \"PAGE\"\n          value: {\n            ...cacheEntry.value,\n            kind:\n              cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n                ? 'PAGE'\n                : cacheEntry.value?.kind,\n          },\n        },\n        {\n          url: getRequestMeta(req, 'initURL'),\n        }\n      )\n      if (finished) {\n        // TODO: maybe we have to end the request?\n        return null\n      }\n    }\n\n    if (!cachedData) {\n      // add revalidate metadata before rendering 404 page\n      // so that we can use this as source of truth for the\n      // cache-control header instead of what the 404 page returns\n      // for the revalidate value\n      addRequestMeta(\n        req,\n        'notFoundRevalidate',\n        cacheEntry.cacheControl?.revalidate\n      )\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (cacheEntry.cacheControl && !res.getHeader('Cache-Control')) {\n        res.setHeader(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n      if (isNextDataRequest) {\n        res.statusCode = 404\n        res.body('{\"notFound\":true}').send()\n        return null\n      }\n\n      if (this.renderOpts.dev) {\n        addRequestMeta(req, 'developmentNotFoundSourcePage', pathname)\n      }\n      await this.render404(req, res, { pathname, query }, false)\n      return null\n    } else if (cachedData.kind === CachedRouteKind.REDIRECT) {\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (cacheEntry.cacheControl && !res.getHeader('Cache-Control')) {\n        res.setHeader(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      if (isNextDataRequest) {\n        return {\n          type: 'json',\n          body: RenderResult.fromStatic(\n            // @TODO: Handle flight data.\n            JSON.stringify(cachedData.props)\n          ),\n          cacheControl: cacheEntry.cacheControl,\n        }\n      } else {\n        await handleRedirect(cachedData.props)\n        return null\n      }\n    } else if (cachedData.kind === CachedRouteKind.APP_ROUTE) {\n      const headers = fromNodeOutgoingHttpHeaders(cachedData.headers)\n\n      if (!(this.minimalMode && isSSG)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        req,\n        res,\n        new Response(cachedData.body, {\n          headers,\n          status: cachedData.status || 200,\n        })\n      )\n      return null\n    } else if (cachedData.kind === CachedRouteKind.APP_PAGE) {\n      // If the request has a postponed state and it's a resume request we\n      // should error.\n      if (didPostpone && minimalPostponed) {\n        throw new Error(\n          'Invariant: postponed state should not be present on a resume request'\n        )\n      }\n\n      if (cachedData.headers) {\n        const headers = { ...cachedData.headers }\n\n        if (!this.minimalMode || !isSSG) {\n          delete headers[NEXT_CACHE_TAGS_HEADER]\n        }\n\n        for (let [key, value] of Object.entries(headers)) {\n          if (typeof value === 'undefined') continue\n\n          if (Array.isArray(value)) {\n            for (const v of value) {\n              res.appendHeader(key, v)\n            }\n          } else if (typeof value === 'number') {\n            value = value.toString()\n            res.appendHeader(key, value)\n          } else {\n            res.appendHeader(key, value)\n          }\n        }\n      }\n\n      // Add the cache tags header to the response if it exists and we're in\n      // minimal mode while rendering a static page.\n      const tags = cachedData.headers?.[NEXT_CACHE_TAGS_HEADER]\n      if (this.minimalMode && isSSG && tags && typeof tags === 'string') {\n        res.setHeader(NEXT_CACHE_TAGS_HEADER, tags)\n      }\n\n      // If the request is a data request, then we shouldn't set the status code\n      // from the response because it should always be 200. This should be gated\n      // behind the experimental PPR flag.\n      if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n        res.statusCode = cachedData.status\n      }\n\n      // Mark that the request did postpone.\n      if (didPostpone) {\n        res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n      }\n\n      // we don't go through this block when preview mode is true\n      // as preview mode is a dynamic request (bypasses cache) and doesn't\n      // generate both HTML and payloads in the same request so continue to just\n      // return the generated payload\n      if (isRSCRequest && !isPreviewMode) {\n        // If this is a dynamic RSC request, then stream the response.\n        if (typeof cachedData.rscData === 'undefined') {\n          if (cachedData.postponed) {\n            throw new Error('Invariant: Expected postponed to be undefined')\n          }\n\n          return {\n            type: 'rsc',\n            body: cachedData.html,\n            // Dynamic RSC responses cannot be cached, even if they're\n            // configured with `force-static` because we have no way of\n            // distinguishing between `force-static` and pages that have no\n            // postponed state.\n            // TODO: distinguish `force-static` from pages with no postponed state (static)\n            cacheControl: isDynamicRSCRequest\n              ? { revalidate: 0, expire: undefined }\n              : cacheEntry.cacheControl,\n          }\n        }\n\n        // As this isn't a prefetch request, we should serve the static flight\n        // data.\n        return {\n          type: 'rsc',\n          body: RenderResult.fromStatic(cachedData.rscData),\n          cacheControl: cacheEntry.cacheControl,\n        }\n      }\n\n      // This is a request for HTML data.\n      let body = cachedData.html\n\n      // If there's no postponed state, we should just serve the HTML. This\n      // should also be the case for a resume request because it's completed\n      // as a server render (rather than a static render).\n      if (!didPostpone || this.minimalMode) {\n        return {\n          type: 'html',\n          body,\n          cacheControl: cacheEntry.cacheControl,\n        }\n      }\n\n      // If we're debugging the static shell or the dynamic API accesses, we\n      // should just serve the HTML without resuming the render. The returned\n      // HTML will be the static shell so all the Dynamic API's will be used\n      // during static generation.\n      if (isDebugStaticShell || isDebugDynamicAccesses) {\n        // Since we're not resuming the render, we need to at least add the\n        // closing body and html tags to create valid HTML.\n        body.chain(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n              controller.close()\n            },\n          })\n        )\n\n        return {\n          type: 'html',\n          body,\n          cacheControl: { revalidate: 0, expire: undefined },\n        }\n      }\n\n      // This request has postponed, so let's create a new transformer that the\n      // dynamic data can pipe to that will attach the dynamic data to the end\n      // of the response.\n      const transformer = new TransformStream<Uint8Array, Uint8Array>()\n      body.chain(transformer.readable)\n\n      // Perform the render again, but this time, provide the postponed state.\n      // We don't await because we want the result to start streaming now, and\n      // we've already chained the transformer's readable to the render result.\n      doRender({\n        postponed: cachedData.postponed,\n        pagesFallback: undefined,\n        // This is a resume render, not a fallback render, so we don't need to\n        // set this.\n        fallbackRouteParams: null,\n      })\n        .then(async (result) => {\n          if (!result) {\n            throw new Error('Invariant: expected a result to be returned')\n          }\n\n          if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n            throw new Error(\n              `Invariant: expected a page response, got ${result.value?.kind}`\n            )\n          }\n\n          // Pipe the resume result to the transformer.\n          await result.value.html.pipeTo(transformer.writable)\n        })\n        .catch((err) => {\n          // An error occurred during piping or preparing the render, abort\n          // the transformers writer so we can terminate the stream.\n          transformer.writable.abort(err).catch((e) => {\n            console.error(\"couldn't abort transformer\", e)\n          })\n        })\n\n      return {\n        type: 'html',\n        body,\n        // We don't want to cache the response if it has postponed data because\n        // the response being sent to the client it's dynamic parts are streamed\n        // to the client on the same request.\n        cacheControl: { revalidate: 0, expire: undefined },\n      }\n    } else if (isNextDataRequest) {\n      return {\n        type: 'json',\n        body: RenderResult.fromStatic(JSON.stringify(cachedData.pageData)),\n        cacheControl: cacheEntry.cacheControl,\n      }\n    } else {\n      return {\n        type: 'html',\n        body: cachedData.html,\n        cacheControl: cacheEntry.cacheControl,\n      }\n    }\n  }\n\n  private stripNextDataPath(path: string, stripLocale = true) {\n    if (path.includes(this.buildId)) {\n      const splitPath = path.substring(\n        path.indexOf(this.buildId) + this.buildId.length\n      )\n\n      path = denormalizePagePath(splitPath.replace(/\\.json$/, ''))\n    }\n\n    if (this.localeNormalizer && stripLocale) {\n      return this.localeNormalizer.normalize(path)\n    }\n    return path\n  }\n\n  // map the route to the actual bundle name\n  protected getOriginalAppPaths(route: string) {\n    if (this.enabledDirectories.app) {\n      const originalAppPath = this.appPathRoutes?.[route]\n\n      if (!originalAppPath) {\n        return null\n      }\n\n      return originalAppPath\n    }\n    return null\n  }\n\n  protected async renderPageComponent(\n    ctx: RequestContext<ServerRequest, ServerResponse>,\n    bubbleNoFallback: boolean\n  ) {\n    const { query, pathname } = ctx\n\n    const appPaths = this.getOriginalAppPaths(pathname)\n    const isAppPath = Array.isArray(appPaths)\n\n    let page = pathname\n    if (isAppPath) {\n      // the last item in the array is the root page, if there are parallel routes\n      page = appPaths[appPaths.length - 1]\n    }\n\n    const result = await this.findPageComponents({\n      locale: getRequestMeta(ctx.req, 'locale'),\n      page,\n      query,\n      params: ctx.renderOpts.params || {},\n      isAppPath,\n      sriEnabled: !!this.nextConfig.experimental.sri?.algorithm,\n      appPaths,\n      // Ensuring for loading page component routes is done via the matcher.\n      shouldEnsure: false,\n    })\n    if (result) {\n      getTracer().setRootSpanAttribute('next.route', pathname)\n      try {\n        return await this.renderToResponseWithComponents(ctx, result)\n      } catch (err) {\n        const isNoFallbackError = err instanceof NoFallbackError\n\n        if (!isNoFallbackError || (isNoFallbackError && bubbleNoFallback)) {\n          throw err\n        }\n      }\n    }\n    return false\n  }\n\n  private async renderToResponse(\n    ctx: RequestContext<ServerRequest, ServerResponse>\n  ): Promise<ResponsePayload | null> {\n    return getTracer().trace(\n      BaseServerSpan.renderToResponse,\n      {\n        spanName: `rendering page`,\n        attributes: {\n          'next.route': ctx.pathname,\n        },\n      },\n      async () => {\n        return this.renderToResponseImpl(ctx)\n      }\n    )\n  }\n\n  protected abstract getMiddleware(): Promise<MiddlewareRoutingItem | undefined>\n  protected abstract getFallbackErrorComponents(\n    url?: string\n  ): Promise<LoadComponentsReturnType | null>\n  protected abstract getRoutesManifest(): NormalizedRouteManifest | undefined\n\n  private async renderToResponseImpl(\n    ctx: RequestContext<ServerRequest, ServerResponse>\n  ): Promise<ResponsePayload | null> {\n    const { req, res, query, pathname } = ctx\n    let page = pathname\n    const bubbleNoFallback =\n      getRequestMeta(ctx.req, 'bubbleNoFallback') ?? false\n    addRequestMeta(\n      ctx.req,\n      'cacheBustingSearchParam',\n      query[NEXT_RSC_UNION_QUERY]\n    )\n    delete query[NEXT_RSC_UNION_QUERY]\n\n    const options: MatchOptions = {\n      i18n: this.i18nProvider?.fromRequest(req, pathname),\n    }\n\n    try {\n      for await (const match of this.matchers.matchAll(pathname, options)) {\n        // when a specific invoke-output is meant to be matched\n        // ensure a prior dynamic route/page doesn't take priority\n        const invokeOutput = getRequestMeta(ctx.req, 'invokeOutput')\n        if (\n          !this.minimalMode &&\n          typeof invokeOutput === 'string' &&\n          isDynamicRoute(invokeOutput || '') &&\n          invokeOutput !== match.definition.pathname\n        ) {\n          continue\n        }\n\n        const result = await this.renderPageComponent(\n          {\n            ...ctx,\n            pathname: match.definition.pathname,\n            renderOpts: {\n              ...ctx.renderOpts,\n              params: match.params,\n            },\n          },\n          bubbleNoFallback\n        )\n        if (result !== false) return result\n      }\n\n      // currently edge functions aren't receiving the x-matched-path\n      // header so we need to fallback to matching the current page\n      // when we weren't able to match via dynamic route to handle\n      // the rewrite case\n      // @ts-expect-error extended in child class web-server\n      if (this.serverOptions.webServerConfig) {\n        // @ts-expect-error extended in child class web-server\n        ctx.pathname = this.serverOptions.webServerConfig.page\n        const result = await this.renderPageComponent(ctx, bubbleNoFallback)\n        if (result !== false) return result\n      }\n    } catch (error) {\n      const err = getProperError(error)\n\n      if (error instanceof MissingStaticPage) {\n        console.error(\n          'Invariant: failed to load static page',\n          JSON.stringify(\n            {\n              page,\n              url: ctx.req.url,\n              matchedPath: ctx.req.headers[MATCHED_PATH_HEADER],\n              initUrl: getRequestMeta(ctx.req, 'initURL'),\n              didRewrite: !!getRequestMeta(ctx.req, 'rewroteURL'),\n              rewroteUrl: getRequestMeta(ctx.req, 'rewroteURL'),\n            },\n            null,\n            2\n          )\n        )\n        throw err\n      }\n\n      if (err instanceof NoFallbackError && bubbleNoFallback) {\n        throw err\n      }\n      if (err instanceof DecodeError || err instanceof NormalizeError) {\n        res.statusCode = 400\n        return await this.renderErrorToResponse(ctx, err)\n      }\n\n      res.statusCode = 500\n\n      // if pages/500 is present we still need to trigger\n      // /_error `getInitialProps` to allow reporting error\n      if (await this.hasPage('/500')) {\n        addRequestMeta(ctx.req, 'customErrorRender', true)\n        await this.renderErrorToResponse(ctx, err)\n        removeRequestMeta(ctx.req, 'customErrorRender')\n      }\n\n      const isWrappedError = err instanceof WrappedBuildError\n\n      if (!isWrappedError) {\n        if (\n          (this.minimalMode && process.env.NEXT_RUNTIME !== 'edge') ||\n          this.renderOpts.dev\n        ) {\n          if (isError(err)) err.page = page\n          throw err\n        }\n        this.logError(getProperError(err))\n      }\n      const response = await this.renderErrorToResponse(\n        ctx,\n        isWrappedError ? (err as WrappedBuildError).innerError : err\n      )\n      return response\n    }\n\n    const middleware = await this.getMiddleware()\n    if (\n      middleware &&\n      !!ctx.req.headers['x-nextjs-data'] &&\n      (!res.statusCode || res.statusCode === 200 || res.statusCode === 404)\n    ) {\n      const locale = getRequestMeta(req, 'locale')\n\n      res.setHeader(\n        'x-nextjs-matched-path',\n        `${locale ? `/${locale}` : ''}${pathname}`\n      )\n      res.statusCode = 200\n      res.setHeader('content-type', 'application/json')\n      res.body('{}')\n      res.send()\n      return null\n    }\n\n    res.statusCode = 404\n    return this.renderErrorToResponse(ctx, null)\n  }\n\n  public async renderToHTML(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return getTracer().trace(BaseServerSpan.renderToHTML, async () => {\n      return this.renderToHTMLImpl(req, res, pathname, query)\n    })\n  }\n\n  private async renderToHTMLImpl(\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  public async renderError(\n    err: Error | null,\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    setHeaders = true\n  ): Promise<void> {\n    return getTracer().trace(BaseServerSpan.renderError, async () => {\n      return this.renderErrorImpl(err, req, res, pathname, query, setHeaders)\n    })\n  }\n\n  private async renderErrorImpl(\n    err: Error | null,\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    setHeaders = true\n  ): Promise<void> {\n    if (setHeaders) {\n      res.setHeader(\n        'Cache-Control',\n        'private, no-cache, no-store, max-age=0, must-revalidate'\n      )\n    }\n\n    return this.pipe(\n      async (ctx) => {\n        const response = await this.renderErrorToResponse(ctx, err)\n        if (this.minimalMode && res.statusCode === 500) {\n          throw err\n        }\n        return response\n      },\n      { req, res, pathname, query }\n    )\n  }\n\n  private customErrorNo404Warn = execOnce(() => {\n    Log.warn(\n      `You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.\\nSee here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`\n    )\n  })\n\n  private async renderErrorToResponse(\n    ctx: RequestContext<ServerRequest, ServerResponse>,\n    err: Error | null\n  ): Promise<ResponsePayload | null> {\n    return getTracer().trace(BaseServerSpan.renderErrorToResponse, async () => {\n      return this.renderErrorToResponseImpl(ctx, err)\n    })\n  }\n\n  protected async renderErrorToResponseImpl(\n    ctx: RequestContext<ServerRequest, ServerResponse>,\n    err: Error | null\n  ): Promise<ResponsePayload | null> {\n    // Short-circuit favicon.ico in development to avoid compiling 404 page when the app has no favicon.ico.\n    // Since favicon.ico is automatically requested by the browser.\n    if (this.renderOpts.dev && ctx.pathname === '/favicon.ico') {\n      return {\n        type: 'html',\n        body: RenderResult.fromStatic(''),\n      }\n    }\n    const { res, query } = ctx\n\n    try {\n      let result: null | FindComponentsResult = null\n\n      const is404 = res.statusCode === 404\n      let using404Page = false\n\n      if (is404) {\n        if (this.enabledDirectories.app) {\n          // Use the not-found entry in app directory\n          result = await this.findPageComponents({\n            locale: getRequestMeta(ctx.req, 'locale'),\n            page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n            query,\n            params: {},\n            isAppPath: true,\n            shouldEnsure: true,\n            url: ctx.req.url,\n          })\n          using404Page = result !== null\n        }\n\n        if (!result && (await this.hasPage('/404'))) {\n          result = await this.findPageComponents({\n            locale: getRequestMeta(ctx.req, 'locale'),\n            page: '/404',\n            query,\n            params: {},\n            isAppPath: false,\n            // Ensuring can't be done here because you never \"match\" a 404 route.\n            shouldEnsure: true,\n            url: ctx.req.url,\n          })\n          using404Page = result !== null\n        }\n      }\n      let statusPage = `/${res.statusCode}`\n\n      if (\n        !getRequestMeta(ctx.req, 'customErrorRender') &&\n        !result &&\n        STATIC_STATUS_PAGES.includes(statusPage)\n      ) {\n        // skip ensuring /500 in dev mode as it isn't used and the\n        // dev overlay is used instead\n        if (statusPage !== '/500' || !this.renderOpts.dev) {\n          result = await this.findPageComponents({\n            locale: getRequestMeta(ctx.req, 'locale'),\n            page: statusPage,\n            query,\n            params: {},\n            isAppPath: false,\n            // Ensuring can't be done here because you never \"match\" a 500\n            // route.\n            shouldEnsure: true,\n            url: ctx.req.url,\n          })\n        }\n      }\n\n      if (!result) {\n        result = await this.findPageComponents({\n          locale: getRequestMeta(ctx.req, 'locale'),\n          page: '/_error',\n          query,\n          params: {},\n          isAppPath: false,\n          // Ensuring can't be done here because you never \"match\" an error\n          // route.\n          shouldEnsure: true,\n          url: ctx.req.url,\n        })\n        statusPage = '/_error'\n      }\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        !using404Page &&\n        (await this.hasPage('/_error')) &&\n        !(await this.hasPage('/404'))\n      ) {\n        this.customErrorNo404Warn()\n      }\n\n      if (!result) {\n        // this can occur when a project directory has been moved/deleted\n        // which is handled in the parent process in development\n        if (this.renderOpts.dev) {\n          return {\n            type: 'html',\n            // wait for dev-server to restart before refreshing\n            body: RenderResult.fromStatic(\n              `\n              <pre>missing required error components, refreshing...</pre>\n              <script>\n                async function check() {\n                  const res = await fetch(location.href).catch(() => ({}))\n\n                  if (res.status === 200) {\n                    location.reload()\n                  } else {\n                    setTimeout(check, 1000)\n                  }\n                }\n                check()\n              </script>`\n            ),\n          }\n        }\n\n        throw new WrappedBuildError(\n          new Error('missing required error components')\n        )\n      }\n\n      // If the page has a route module, use it for the new match. If it doesn't\n      // have a route module, remove the match.\n      if (result.components.routeModule) {\n        addRequestMeta(ctx.req, 'match', {\n          definition: result.components.routeModule.definition,\n          params: undefined,\n        })\n      } else {\n        removeRequestMeta(ctx.req, 'match')\n      }\n\n      try {\n        return await this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: statusPage,\n            renderOpts: {\n              ...ctx.renderOpts,\n              err,\n            },\n          },\n          result\n        )\n      } catch (maybeFallbackError) {\n        if (maybeFallbackError instanceof NoFallbackError) {\n          throw new Error('invariant: failed to render error page')\n        }\n        throw maybeFallbackError\n      }\n    } catch (error) {\n      const renderToHtmlError = getProperError(error)\n      const isWrappedError = renderToHtmlError instanceof WrappedBuildError\n      if (!isWrappedError) {\n        this.logError(renderToHtmlError)\n      }\n      res.statusCode = 500\n      const fallbackComponents = await this.getFallbackErrorComponents(\n        ctx.req.url\n      )\n\n      if (fallbackComponents) {\n        // There was an error, so use it's definition from the route module\n        // to add the match to the request.\n        addRequestMeta(ctx.req, 'match', {\n          definition: fallbackComponents.routeModule!.definition,\n          params: undefined,\n        })\n\n        return this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: '/_error',\n            renderOpts: {\n              ...ctx.renderOpts,\n              // We render `renderToHtmlError` here because `err` is\n              // already captured in the stacktrace.\n              err: isWrappedError\n                ? renderToHtmlError.innerError\n                : renderToHtmlError,\n            },\n          },\n          {\n            query,\n            components: fallbackComponents,\n          }\n        )\n      }\n      return {\n        type: 'html',\n        body: RenderResult.fromStatic('Internal Server Error'),\n      }\n    }\n  }\n\n  public async renderErrorToHTML(\n    err: Error | null,\n    req: ServerRequest,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderErrorToResponse(ctx, err), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  public async render404(\n    req: ServerRequest,\n    res: ServerResponse,\n    parsedUrl?: Pick<NextUrlWithParsedQuery, 'pathname' | 'query'>,\n    setHeaders = true\n  ): Promise<void> {\n    const { pathname, query } = parsedUrl ? parsedUrl : parseUrl(req.url!, true)\n\n    // Ensure the locales are provided on the request meta.\n    if (this.nextConfig.i18n) {\n      if (!getRequestMeta(req, 'locale')) {\n        addRequestMeta(req, 'locale', this.nextConfig.i18n.defaultLocale)\n      }\n      addRequestMeta(req, 'defaultLocale', this.nextConfig.i18n.defaultLocale)\n    }\n\n    res.statusCode = 404\n    return this.renderError(null, req, res, pathname!, query, setHeaders)\n  }\n}\n"],"names":["getFallbackRouteParams","CachedRouteKind","NormalizeError","DecodeError","normalizeRepeatedSlashes","MissingStaticPage","format","formatUrl","parse","parseUrl","formatHostname","getRedirectStatus","isEdgeRuntime","APP_PATHS_MANIFEST","NEXT_BUILTIN_DOCUMENT","PAGES_MANIFEST","STATIC_STATUS_PAGES","UNDERSCORE_NOT_FOUND_ROUTE","UNDERSCORE_NOT_FOUND_ROUTE_ENTRY","isDynamicRoute","checkIsOnDemandRevalidate","setConfig","getCacheControlHeader","execOnce","isBlockedPage","getBotType","isBot","RenderResult","removeTrailingSlash","denormalizePagePath","Log","getPreviouslyRevalidatedTags","getServerUtils","isError","getProperError","addRequestMeta","getRequestMeta","removeRequestMeta","setRequestMeta","removePathPrefix","normalizeAppPath","getHostname","parseUrlUtil","getNextPathnameInfo","RSC_HEADER","NEXT_RSC_UNION_QUERY","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_URL","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_IS_PRERENDER_HEADER","LocaleRouteNormalizer","DefaultRouteMatcherManager","AppPageRouteMatcherProvider","AppRouteRouteMatcherProvider","PagesAPIRouteMatcherProvider","PagesRouteMatcherProvider","ServerManifestLoader","getTracer","isBubbledError","SpanKind","BaseServerSpan","I18NProvider","sendResponse","fromNodeOutgoingHttpHeaders","normalizeNextQueryParam","toNodeOutgoingHttpHeaders","CACHE_ONE_YEAR","INFINITE_CACHE","MATCHED_PATH_HEADER","NEXT_CACHE_TAGS_HEADER","NEXT_RESUME_HEADER","normalizeLocalePath","NextRequestAdapter","signalFromNodeResponse","matchNextDataPathname","getRouteFromAssetPath","decodePathParams","RSCPathnameNormalizer","stripFlightHeaders","isAppPageRouteModule","isAppRouteRouteModule","isPagesRouteModule","PrefetchRSCPathnameNormalizer","NextDataPathnameNormalizer","getIsPossibleServerAction","isInterceptionRouteAppPath","toRoute","isNodeNextRequest","isNodeNextResponse","patchSetHeaderWithCookieSupport","checkIsAppPPREnabled","getBuiltinRequestContext","ENCODED_TAGS","NextRequestHint","getRevalidateReason","RouteKind","FallbackMode","parseFallbackField","toResponseCacheEntry","SegmentPrefixRSCPathnameNormalizer","shouldServeStreamingMetadata","isHtmlBotRequest","InvariantError","decodeQueryPathParameter","getCacheHandlers","fixMojibake","computeCacheBustingSearchParam","NoFallbackError","Error","WrappedBuildError","constructor","innerError","Server","getServerComponentsHmrCache","nextConfig","experimental","serverComponentsHmrCache","globalThis","__serverComponentsHmrCache","undefined","options","handleRSCRequest","req","_res","parsedUrl","pathname","normalizers","segmentPrefetchRSC","match","result","extract","originalPathname","segmentPath","headers","toLowerCase","prefetchRSC","normalize","rsc","segmentPrefetchRSCRequest","url","parsed","handleNextDataRequest","res","middleware","getMiddleware","params","path","buildId","process","env","NEXT_RUNTIME","render404","shift","lastParam","length","endsWith","join","trailingSlash","substring","i18nProvider","hostname","host","split","domainLocale","detectDomainLocale","defaultLocale","config","localePathResult","analyze","detectedLocale","handleNextImageRequest","handleCatchallRenderRequest","handleCatchallMiddlewareRequest","data","push","normalizer","normalizeAndAttachMetadata","finished","enabledDirectories","pages","prepared","preparedPromise","customErrorNo404Warn","warn","dir","quiet","conf","dev","minimalMode","port","experimentalTestProxy","serverOptions","require","resolve","loadEnvConfig","fetchHostname","distDir","publicDir","getPublicDir","hasStaticDir","getHasStaticDir","i18n","locales","localeNormalizer","serverRuntimeConfig","publicRuntimeConfig","assetPrefix","generateEtags","getBuildId","minimalModeKey","NEXT_PRIVATE_MINIMAL_MODE","getEnabledDirectories","isAppPPREnabled","app","ppr","isAppSegmentPrefetchEnabled","clientSegmentCache","nextFontManifest","getNextFontManifest","NEXT_DEPLOYMENT_ID","deploymentId","renderOpts","supportsDynamicResponse","strictNextHead","poweredByHeader","canonicalBase","amp","previewProps","getPrerenderManifest","preview","ampOptimizerConfig","optimizer","basePath","images","optimizeCss","nextConfigOutput","output","nextScriptWorkers","disableOptimizedLoading","domainLocales","domains","serverComponents","cacheLifeProfiles","cacheLife","enableTainting","taint","crossOrigin","largePageDataBytes","runtimeConfig","Object","keys","isExperimentalCompile","htmlLimitedBots","expireTime","staleTimes","clientTraceMetadata","dynamicIO","Boolean","dynamicOnHover","inlineCss","authInterrupts","onInstrumentationRequestError","instrumentationOnRequestError","bind","reactMaxHeadersLength","devtoolSegmentExplorer","pagesManifest","getPagesManifest","appPathsManifest","getAppPathsManifest","appPathRoutes","getAppPathRoutes","interceptionRoutePatterns","getinterceptionRoutePatterns","matchers","getRouteMatchers","reload","setAssetPrefix","responseCache","getResponseCache","reloadMatchers","manifestLoader","name","args","err","ctx","instrumentation","onRequestError","method","fromEntries","entries","handlerErr","console","error","logError","handleRequest","prepare","toUpperCase","tracer","withPropagatedContext","trace","spanName","kind","SERVER","attributes","span","handleRequestImpl","finally","isRSCRequest","setAttributes","statusCode","rootSpanAttributes","getRootSpanAttributes","get","route","updateName","originalRequest","waitTillReady","originalResponse","urlParts","urlNoQuery","cleanUrl","redirect","body","send","query","URLSearchParams","xForwardedProto","isHttps","socket","encrypted","toString","remoteAddress","attachRequestMeta","replace","pathnameInfo","useMatchedPathHeader","matchedPath","URL","urlPathname","chunk","postponed","Buffer","concat","normalizedUrlPath","stripNextDataPath","localeAnalysisResult","inferredFromDefault","srcPathname","pageIsDynamic","paramsResult","hasValidParams","definition","utils","page","rewrites","getRoutesManifest","beforeFiles","afterFiles","fallback","caseSensitive","caseSensitiveRoutes","locale","originQueryParams","pathnameBeforeRewrite","rewriteParamKeys","handleRewrites","queryParams","didRewrite","routeParamKeys","Set","key","value","normalizedKey","add","Array","isArray","map","v","normalizeDynamicRouteParams","matcherParams","dynamicRouteMatcher","assign","curParamsResult","routeMatchesHeader","routeMatches","getParamsFromRouteMatches","defaultRouteMatches","interpolateDynamicPath","normalizeCdnUrl","defaultRouteRegex","groups","renderError","webServerConfig","protocol","parsedFullUrl","incrementalCache","getIncrementalCache","requestHeaders","requestProtocol","resetRequestCache","__incrementalCache","cacheHandlers","Promise","all","cacheHandler","previouslyRevalidatedTags","previewModeId","receiveExpiredTags","invokePath","useInvokePath","invokeStatus","invokeQuery","parsedMatchedPath","invokePathnameInfo","parseData","normalizeResult","response","Response","bubble","run","code","getRequestHandlerWithMetadata","meta","handler","getRequestHandler","prefix","loadInstrumentationModule","prepareImpl","then","close","forEach","entry","normalizedPath","runImpl","pipe","fn","partialContext","pipeImpl","ua","botType","serveStreamingMetadata","payload","originalStatus","type","cacheControl","sent","setHeader","expire","sendRenderResult","getStaticHTML","toUnchunkedString","render","internalRender","renderImpl","getWaitUntil","builtinRequestContext","waitUntil","getInternalWaitUntil","startsWith","customServer","hasPage","renderToResponse","getStaticPaths","fallbackField","dynamicRoutes","staticPaths","fallbackMode","renderToResponseWithComponents","requestContext","findComponentsResult","renderToResponseWithComponentsImpl","pathCouldBeIntercepted","resolvedPathname","some","regexp","test","setVaryHeader","isAppPath","baseVaryHeader","addedNextUrlToVary","appendHeader","opts","components","prerenderManifest","cacheEntry","isErrorPathname","is404Page","is500Page","hasServerProps","getServerSideProps","hasGetStaticPaths","isPossibleServerAction","hasGetInitialProps","Component","getInitialProps","isSSG","getStaticProps","expectedHash","actualHash","resolvedUrlPathname","hasFallback","isDynamic","pathsResult","resolvedWithoutSlash","includes","routes","isNextDataRequest","isPrefetchRSCRequest","routeModule","couldSupportPPR","hasDebugStaticShellQuery","__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING","__nextppronly","hasDebugFallbackShellQuery","isRoutePPREnabled","renderingMode","isDebugStaticShell","isDebugDynamicAccesses","isDebugFallbackShell","minimalPostponed","isDynamicRSCRequest","segmentPrefetchHeader","isHtmlBot","parseInt","slice","fromStatic","isBotRequest","isSupportedDocument","Document","previewData","isPreviewMode","tryGetPreviewData","multiZoneDraftMode","runtime","isOnDemandRevalidate","revalidateOnlyGenerated","handleRedirect","pageData","destination","pageProps","__N_REDIRECT","__N_REDIRECT_STATUS","__N_REDIRECT_BASE_PATH","ssgCacheKey","doRender","pagesFallback","fallbackRouteParams","origQuery","hadTrailingSlash","resolvedUrl","shouldWaitOnAllReady","isRevalidate","serverActions","resolvedAsPath","isDraftMode","onClose","onAfterTaskError","setIsrStatus","nextExport","isStaticGeneration","context","sharedContext","request","fromNodeNextRequest","handle","fetchMetrics","cacheTags","collectedTags","blob","revalidate","collectedRevalidate","collectedExpire","APP_ROUTE","status","from","arrayBuffer","pendingWaitUntil","routerKind","routePath","routeType","revalidateReason","ComponentMod","parsedInitUrl","search","ampValidator","clientReferenceManifest","renderContext","isFallback","developmentNotFoundSourcePage","module","warmup","metadata","devRenderResumeDataCache","renderHTML","fetchTags","staticBailoutInfo","description","stack","message","indexOf","isNotFound","isRedirect","REDIRECT","props","flightData","isNull","APP_PAGE","html","rscData","segmentData","PAGES","responseGenerator","hasResolved","previousCacheEntry","isRevalidating","isProduction","didRespond","NOT_FOUND","PRERENDER","BLOCKING_STATIC_RENDER","isStale","staticPathKey","isPageIncludedInStaticPaths","fallbackResponse","previousFallbackCacheEntry","routeKind","isPrefetch","purpose","didPostpone","isMiss","cachedData","IMAGE","getHeader","notFoundRevalidate","tags","matchedSegment","onCacheEntry","JSON","stringify","delete","set","chain","ReadableStream","start","controller","enqueue","CLOSED","BODY_AND_HTML","transformer","TransformStream","readable","pipeTo","writable","catch","abort","e","stripLocale","splitPath","getOriginalAppPaths","originalAppPath","renderPageComponent","bubbleNoFallback","appPaths","findPageComponents","sriEnabled","sri","algorithm","shouldEnsure","setRootSpanAttribute","isNoFallbackError","renderToResponseImpl","fromRequest","matchAll","invokeOutput","initUrl","rewroteUrl","renderErrorToResponse","isWrappedError","renderToHTML","renderToHTMLImpl","setHeaders","renderErrorImpl","renderErrorToResponseImpl","is404","using404Page","statusPage","NODE_ENV","maybeFallbackError","renderToHtmlError","fallbackComponents","getFallbackErrorComponents","renderErrorToHTML"],"mappings":"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","ignoreList":[0]}